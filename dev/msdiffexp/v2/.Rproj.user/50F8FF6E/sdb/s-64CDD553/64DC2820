{
    "contents" : "# Based on a Progenesis LC-MS Limma Analysis script\n\n# Load the limma library so we can use it\n# Can be installed by running following commands in R\n#\nsource(\"http://www.bioconductor.org/biocLite.R\")\nif(!require(\"limma\")){ biocLite(\"limma\") }\nif(!require(\"statmod\")){ biocLite(\"statmod\") }\nif(!require(\"ggplot2\")){ install.packages(\"ggplot2\", repos=\"http://cran.fhcrc.org\") }\nif(!require(\"reshape\")){ install.packages(\"reshape\", repos=\"http://cran.fhcrc.org\") }\nif(!require(\"plyr\")){ install.packages(\"plyr\", repos=\"http://cran.fhcrc.org\") }\nif(!require(\"tcltk\")){ install.packages(\"tcltk\", repos=\"http://cran.fhcrc.org\") }\nif(!require(\"gtools\")){ install.packages(\"gtools\", repos=\"http://cran.fhcrc.org\") }\n\nlibrary(limma)\nlibrary(reshape)\nlibrary(plyr)\nlibrary(ggplot2)\nlibrary(tcltk)\nlibrary(gtools)\n\n# DEBUGGING log flag/level (0 translates to no debugging log at all)\ndebuglog <- 10\n# DEBUGGING log indentation level (psoitive int, global) for levellog function\nloglvl <- 0\n#  Print msg with specific indentation (loglvl*3)\n#  - change [int]: change previous indentation level by <change> amount\n#  - reset [bool]: reset indentation level to 0 (no indentation)\n#  - after [bool]: change indentation after printing msg\nlevellog <- function (msg, change=0, reset=F,after=F, supression=debuglog){\n\tprev_loglvl <- loglvl\n\tif(reset){\n\t\tloglvl <<- 0\n\t}\n\telse if(change < 0){\n\t\tif(-change > loglvl){\n\t\t\tloglvl <<- 0\n\t\t}else{\n\t\t\tloglvl <<- loglvl + change\n\t\t}\n\t}else if (change > 0){\n\t\tloglvl <<- loglvl + change\n\t}\n\tif(nchar(msg)>0 && ifelse(after , prev_loglvl<supression , loglvl<supression)){\n\t\tif(after){\n\t\t\tcat(paste(paste(rep(\" \",times=prev_loglvl*3),collapse=\"\"),\" +-- \",msg,\" [\",Sys.time(),\"]\\n\"))\n\t\t}else{\n\t\t\tcat(paste(paste(rep(\" \",times=loglvl*3),collapse=\"\"),\" +-- \",msg,\" [\",Sys.time(),\"]\\n\"))\n\t\t}\n\t}\n}\n\n# FROM: http://musicroamer.com/blog/2011/01/16/r-tips-and-tricks-modified-pairs-plot/\n# Scatterplot matrix functionality\n\npanel.cor.scale <- function(x, y, digits=2, prefix=\"\", cex.cor){\nusr <- par(\"usr\"); on.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr = (cor(x, y,use=\"pairwise\"))\ntxt <- format(c(r, 0.123456789), digits=digits)[1]\ntxt <- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex <- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex * abs(r))\n}\n\npanel.cor <- function(x, y, digits=2, prefix=\"\", cex.cor){\nusr <- par(\"usr\"); on.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr = (cor(x, y,use=\"pairwise\"))\ntxt <- format(c(r, 0.123456789), digits=digits)[1]\ntxt <- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex <- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex )\n}\n\npanel.hist <- function(x, ...){\nusr <- par(\"usr\"); on.exit(par(usr))\npar(usr = c(usr[1:2], 0, 1.5) )\n#h <- hist(x, plot = FALSE)\nh <- hist(x, breaks=panel.hist.breaks,plot = FALSE)\nbreaks <- h$breaks; nB <- length(breaks)\ny <- h$counts; y <- y/max(y)\nrect(breaks[-nB], 0, breaks[-1], y, col=ratios.hist.colour, ...)\n}\n\n# FROM: http://www-personal.umich.edu/~ladamic/presentations/Rtutorial/Rtutorial.R\npanel.lmline = function (x, y, col = par(\"col\"), bg = NA, pch = par(\"pch\"), cex = 1, col.smooth = reps.scatter.lmline.colour, ...){\n    points(x, y, pch = pch, col = col, bg = bg, cex = cex)\n    ok <- is.finite(x) & is.finite(y)\n    if (any(ok)) \n       abline(lm(y[ok] ~ x[ok]), \n           col = col.smooth, ...)\n}\n\npairs.panels <- function (x,y,smooth=TRUE,scale=FALSE,lm=FALSE){\n\tif (smooth){\n\t\tif (scale) {\n\t\t\tif(lm){\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale,lower.panel=panel.lmline)\n\t\t\t}else{\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale,lower.panel=panel.smooth)\n\t\t\t}\n\t\t}else{\n\t\t\tif(lm){\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor,lower.panel=panel.lmline)\n\t\t\t}else{\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor,lower.panel=panel.smooth)\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(scale){\n\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale)\n\t\t}else{\n\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor)\n\t\t}\n\t}\n}\n\nlm_eqn<-function(df){\n    m = lm(y ~ x, data=df);\n    eq <- substitute(italic(y) == a + b %.% italic(x)*\",\"~~italic(r)^2~\"=\"~r2, \n         list(a = format(coef(m)[1], digits = 2), \n              b = format(coef(m)[2], digits = 2), \n             r2 = format(summary(m)$r.squared, digits = 3)))\n    return(as.character(as.expression(eq)));\n}\n\n# to be used with apply on a limma-results data.frame\n# calculate mean, sd and N of ratios between available channels\n# conds_cols_idxs the column indexes of quant channels intensities\n# x a limma-results data.frame row\ncalcRowStats<-function(x,conds_cols_idxs,ratio_combs){\n  ratios<-c()\n  m<-c()\n  std<-c()\n  N<-c()\n  avg.I<-c()\n  \n  for(i in 1:nrow(ratio_combs)){\n    tmp1<-as.numeric(x[conds_cols_idxs[ratio_combs[i,2],]]) #columns of heavier label (assumed to be defined after lighter label in conditions.labels)\n    tmp2<-as.numeric(x[conds_cols_idxs[ratio_combs[i,1],]]) #columns of lighter label    \n    ratio_i<-(tmp1-tmp2)\n    ratios<-rbind(ratios, ratio_i)\n    m<-rbind(m, mean(ratio_i,na.rm=T))\n    std<-rbind(std, sd(ratio_i,na.rm=T))\n    N<-rbind(N, length(which(!is.na(ratio_i)|ratio_i==0)))\n\n    #avg.I<-rbind(avg.I, log2(mean(sapply(1:nrow(conds_cols_idxs),function(x) sum(c(2^tmp1[x],2^tmp2[x]),na.rm=T)),na.rm=T)))\n    avg.I<-rbind(avg.I, mean(c(tmp1,tmp2),na.rm=T))\n  }\n\n\treturn(c(m[,1],std[,1],N[,1],avg.I[,1],as.vector(t(ratios))))\n}\n\n# Produces S-plot, Volcano plot, MA plot and Scatterplot (matrix). Called by do_limma_analysis subroutine.\ndo_results_plots<-function(norm.median.intensities,time.point,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n  levellog(\"\",change=1)\n\t\n  ratio_combs<-combinations(nConditions,2,1:nConditions)\n  levellog(\"Preparing data ...\")\n  results<-read.table(paste(outputFigsPrefix,\"_condition-i_vs_condition-j_\",time.point,\".txt\",sep=\"\"), header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n  if(nrow(ratio_combs) == 1){\n    colnames(results)[grep(\"p\\\\.value\\\\.adj\",colnames(results))]<-paste(\"p.value.adj.\",conditions.labels[2],\".\",conditions.labels[1],sep=\"\")\n  }#else{\n  #  for(i in 1:nrow(ratio_combs)){\n  #    ratio_i_desc<-paste(conditions.labels[ratio_combs[i,2]],\"\\\\.\",conditions.labels[ratio_combs[i,1]],sep=\"\")\n  #    ratio_i_sub<-paste(\"L\",ratio_combs[i,2],\"...L\",ratio_combs[i,1],sep=\"\")\n  #    colnames(results)<-gsub(ratio_i_desc,ratio_i_sub,colnames(results))\n  #  }\n  #}\n  \n  # Due to the mysterious bug (undefined results$ID column), the following does not make sense ...\n  #rownames(results)<-results$ID\n  #\n  tmp<-as.data.frame(t(norm.median.intensities))\n\n  #rownames(tmp)<-colnames(norm.median.intensities)\n  \n  nsamples<-length(colnames(tmp))/nConditions\n  colnames(tmp)<-apply(data.frame(cbind(rep(conditions.labels,each=nsamples),rep(1:nsamples))),1,function(x) paste(x['X1'],x['X2']))\n  results<-cbind(results,tmp)\n   \n  results$N<-apply(results[,colnames(tmp)],1,function(x)(nsamples*nConditions)-length(which(is.na(x))))\n  \n  levellog(\"Filtering data based on P-value(s) ...\")\n  signTruth<-rep(FALSE,nrow(results))\n  for(i in 1:nrow(ratio_combs)){\n    col_desc_<-paste(\"p.value.adj.\",paste(conditions.labels[ratio_combs[i,2]],\".\",conditions.labels[ratio_combs[i,1]],sep=\"\"),sep=\"\")\n    na_indexes<-which(is.na(results[,col_desc_]))\n    if(length(na_indexes)>0){\n      results[na_indexes,col_desc_]<-1\n      signTruth<-(signTruth | results[,col_desc_]<0.05)\n      results[na_indexes,col_desc_]<-NA\n    }else{\n      signTruth<-(signTruth | results[,col_desc_]<0.05)\n    }\n  }\n\n  ndiffexp<-nrow(results[signTruth,])\n  \n  conds_cols_idxs<-c()\n  for(lbl_i in conditions.labels){\n    conds_cols_idxs<-rbind(conds_cols_idxs, grep(paste(\"^\",lbl_i,sep=\"\"),colnames(results)))\n  }\n  \n  levellog(\"Calculating data frame-row statistics ...\")\n  d<-data.frame(t(apply(results,1, function(x) calcRowStats(x,conds_cols_idxs,ratio_combs))))\n  levellog(\"Performing final formatting operations ...\")\n  colnames_d_<-c()\n\n  for(i in 1:nrow(ratio_combs)){\n    ratio_i_str<-paste(conditions.labels[ratio_combs[i,2]],\".\",conditions.labels[ratio_combs[i,1]],sep=\"\")\n    colnames_d_<-rbind(colnames_d_, c(\n      paste(\"log2.avg.\",ratio_i_str,sep=\"\"),\n      paste(\"log2.sd.\",ratio_i_str,sep=\"\"),\n      paste(\"log2.N.\",ratio_i_str,sep=\"\"),\n      paste(\"log2.avg.I.\",ratio_i_str,sep=\"\")))\n  }\n  colnames_d_<-as.vector(colnames_d_)\n  for(i in 1:nrow(ratio_combs)){\n    ratio_i_str<-paste(conditions.labels[ratio_combs[i,2]],\".\",conditions.labels[ratio_combs[i,1]],sep=\"\")\n    colnames_d_<-c(colnames_d_, paste(paste(\"log2.\",ratio_i_str,sep=\"\"),1:nsamples))\n  }\n  colnames(d)<-colnames_d_\n\n  # Due to the mysterious bug, the following was added ...\n  results$ID <- rownames(results)\n  results<-cbind(results,d)\n  #\n  results$ID <- factor(results$ID, levels=unique(as.character(results$ID)))\n  results$nID<-1:nrow(results)\n  \n  levellog(\"Plotting time ...\")\n  theme_set(theme_bw())\n  # customized colorblind-friendly palette from http://wiki.stdout.org/rcookbook/Graphs/Colors%20(ggplot2)/\n  cbPalette <- c(\"#999999\", \"#D55E00\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#CC79A7\")\n  \n  #my plots\n  for(i in 1:nrow(ratio_combs)){\n\tlevellog(paste(\"Generating plots for combination #\",i,\" ...\"),change=1,after=T)\n    ratio_i_str<-paste(conditions.labels[ratio_combs[i,2]],\".\",conditions.labels[ratio_combs[i,1]],sep=\"\")\n    \n    # 1 - volcano - -log10 P-value vs log ratio\n\tlevellog(\"Making volcano plot ...\")\n    figsuffix<-paste(\"_\",ratio_i_str,\"-volcano\",\"_\",sep=\"\")\n    \n    if(exportFormat == \"pdf\"){\n      pdf(file=paste(outputFigsPrefix,figsuffix,time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n    }\n\n\tratio_i_<-paste(\"log2.\",ratio_i_str,sep=\"\")\n    ratio_i_sd_col<-paste(\"log2.sd.\",ratio_i_str,sep=\"\")\n\ttmp2<-results[,colnames(results)[grep(gsub(\"\\\\.\",\"\\\\\\\\.\",ratio_i_),colnames(results))]]+results[,colnames(results)[grep(gsub(\"\\\\.\",\"\\\\\\\\.\",ratio_i_sd_col),colnames(results))]]\n\n\ttmp1<-results[,colnames(results)[grep(gsub(\"\\\\.\",\"\\\\\\\\.\",ratio_i_),colnames(results))]]-results[,colnames(results)[grep(gsub(\"\\\\.\",\"\\\\\\\\.\",ratio_i_sd_col),colnames(results))]]\n\tratiolim<-ceiling(max(max(range(tmp1,na.rm=T),range(tmp2,na.rm=T)),abs(min(range(tmp1,na.rm=T),range(tmp2,na.rm=T)))))\n    panel.hist.breaks<<-(-ratiolim:ratiolim)\n    \n    ratio_i_p.value.adj<-paste(\"p.value.adj.\",paste(conditions.labels[ratio_combs[i,2]],\".\",conditions.labels[ratio_combs[i,1]],sep=\"\"),sep=\"\")\n    ratio_i_avg_col<-paste(\"log2.avg.\",ratio_i_str,sep=\"\")\n    mlog10_ratio_i_p.value.adj<-paste(\"mlog10_\",ratio_i_p.value.adj,sep=\"\")\n    diffexp_ratio_i<-paste(\"diffexp_\",ratio_i_str,sep=\"\")\n    \n    results[,mlog10_ratio_i_p.value.adj]<-(-log10(results[,ratio_i_p.value.adj]))\n\n    na_indexes<-which(is.na(results[,ratio_i_p.value.adj]))\n    if(length(na_indexes)>0){\n      results[na_indexes,ratio_i_p.value.adj]<-1\n      results[,diffexp_ratio_i]<-results[,ratio_i_p.value.adj]<0.05\n      results[na_indexes,ratio_i_p.value.adj]<-NA\n    }else{\n      results[,diffexp_ratio_i]<-results[,ratio_i_p.value.adj]<0.05\n    }\n\n    p<-ggplot(data=results, aes_string(x=ratio_i_avg_col, y=mlog10_ratio_i_p.value.adj, colour=diffexp_ratio_i)) +\n      geom_point(alpha=0.7, size=1.75) +\n      theme(legend.position = \"none\", axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0), plot.title = element_text(vjust=1.5, lineheight=.8, face=\"bold\")) +\n      xlim(c(-ratiolim, ratiolim)) + ylim(c(0, 6)) + scale_colour_manual(values=cbPalette) +\n      xlab(paste(\"average log2 \",sub(\"\\\\.\",\"/\",ratio_i_str),sep=\"\")) + ylab(\"-log10 P-value\") + ggtitle(\"P-value vs Fold change\") +\n      geom_hline(aes(yintercept=-log10(0.05)), colour=\"#990000\", linetype=\"dashed\") +\n      geom_text(size=2.5, hjust=1, vjust=-0.5,aes(x=-4.2, y=-log10(0.05)), label=\"P-value=0.05\",colour=\"#990000\")\n    print(p)\n\n    if(exportFormat == \"emf\"){\n      savePlot(filename=paste(outputFigsPrefix,figsuffix,time.point,\".emf\",sep=\"\"),type=\"emf\")\n    }\n    dev.off()\n    \n    # 2 - value-ordered - log ratio\n\tlevellog(\"Making value-ordered plot ...\")\n    figsuffix<-paste(\"_\",ratio_i_str,\"-value-ordered-log-ratio\",\"_\",sep=\"\")\n    \n    if(exportFormat == \"pdf\"){\n      pdf(file=paste(outputFigsPrefix,figsuffix,time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n    }\n    \n    results<-results[with(results, order(results[,c(ratio_i_avg_col)])),]\n    results$nID<-1:nrow(results)\n    ratio_i_avg_col_ymax<-paste(ratio_i_avg_col,\".ymax\",sep=\"\")\n    ratio_i_avg_col_ymin<-paste(ratio_i_avg_col,\".ymin\",sep=\"\")\n    results[,ratio_i_avg_col_ymax]<-results[,ratio_i_avg_col]+results[,ratio_i_sd_col]\n    results[,ratio_i_avg_col_ymin]<-results[,ratio_i_avg_col]-results[,ratio_i_sd_col]\n    \n    p<-ggplot(data=results, aes_string(x=\"nID\", y=ratio_i_avg_col, colour=diffexp_ratio_i)) +\n      geom_point(alpha=0.7, size=1.5) +\n      geom_errorbar(aes_string(ymin=ratio_i_avg_col_ymin, ymax=ratio_i_avg_col_ymax), width=1.5) +\n      theme(legend.position = \"none\", axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0), plot.title = element_text(vjust=1.5, lineheight=.8, face=\"bold\")) +\n      ylim(c(-ratiolim, ratiolim)) + scale_colour_manual(values=cbPalette) +\n      xlab(paste(quantitated_items_lbl,\"ID\")) + ylab(paste(\"average log2 \",sub(\"\\\\.\",\"/\",ratio_i_str),sep=\"\")) + ggtitle(\"Value-ordered fold change\")\n    print(p)\n    \n    if(exportFormat == \"emf\"){\n      savePlot(filename=paste(outputFigsPrefix,figsuffix,time.point,\".emf\",sep=\"\"),type=\"emf\")\n    }\n    dev.off()    \n    \n    # 3 - MA plot\n\tlevellog(\"Making MA plot ...\")\n    figsuffix<-paste(\"_\",ratio_i_str,\"-MA\",\"_\",sep=\"\")\n    ratio_i_avgI_col<-paste(\"log2.avg.I.\",ratio_i_str,sep=\"\")\n    \n    if(exportFormat == \"pdf\"){\n      pdf(file=paste(outputFigsPrefix,figsuffix,time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n    }\n    \n    p<-ggplot(data=results, aes_string(x=ratio_i_avgI_col, y=ratio_i_avg_col, colour=diffexp_ratio_i)) +\n      geom_point(alpha=0.7, size=1.75) +\n      theme(legend.position = \"none\", axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0), plot.title = element_text(vjust=1.5, lineheight=.8, face=\"bold\")) +\n      ylim(c(-ratiolim, ratiolim)) + scale_colour_manual(values=cbPalette) +\n      xlab(\"M (average log2 Intensity)\") + ylab(paste(\"A (average log2 \",sub(\"\\\\.\",\"/\",ratio_i_str),\")\",sep=\"\")) + ggtitle(\"MA plot\")\n    print(p)\n    \n    if(exportFormat == \"emf\"){\n      savePlot(filename=paste(outputFigsPrefix,figsuffix,time.point,\".emf\",sep=\"\"),type=\"emf\")\n    }\n    dev.off()\n    \n    # 4 - reproducibility plots & histograms\n\tlevellog(\"Making reproducibility plot ...\")\n    figsuffix<-paste(\"_\",ratio_i_str,\"-reproducibility\",\"_\",sep=\"\")\n    \n    allratios<-results[,colnames(results)[grep(ratio_i_,colnames(results))]]\n    colnames(allratios)<-sub(ratio_i_,paste(\"log2(\",sub(\"\\\\.\",\"/\",ratio_i_str),\") \",sep=\"\"),colnames(allratios))\n    \n    if(exportFormat == \"pdf\"){\n      pdf(file=paste(outputFigsPrefix,figsuffix,time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n    }\n    \n    pairs.panels(allratios,scale=T,lm=T)\n    \n    if(exportFormat == \"emf\"){\n      savePlot(filename=paste(outputFigsPrefix,figsuffix,time.point,\".emf\",sep=\"\"),type=\"emf\")\n    }\n    dev.off()\n\tlevellog(\"\",change=-1)\n  }\n  \n  levellog(\"Saving plots results to files ...\")\n  colnames(results)<-gsub(\"[\\\\._]\",\" \",colnames(results))\n  for(i in 1:nrow(ratio_combs)){\n    ratio_i_str<-paste(\"(\",conditions.labels[ratio_combs[i,2]],\") (\",conditions.labels[ratio_combs[i,1]],\")\",sep=\"\")\n    colnames(results)<-gsub(ratio_i_str,\"\\\\1/\\\\2\",colnames(results))\n  }\n  colnames(results)<-gsub(\"p value adj\",\"P-value adjusted\",colnames(results))\n  colnames(results)<-gsub(\"p value\",\"P-value\",colnames(results))\n  colnames(results)<-gsub(\"mlog10\",\"-log10\",colnames(results))\n  colnames(results)<-gsub(\"log2 avg\",\"avg log2\",colnames(results))\n  colnames(results)<-gsub(\"log2 sd\",\"sd log2\",colnames(results))\n  colnames(results)<-gsub(\"log2 N\",\"N log2\",colnames(results))\n  colnames(results)<-gsub(\"ymax\",\"+sd\",colnames(results))\n  colnames(results)<-gsub(\"ymin\",\"-sd\",colnames(results))\n  \n  results<-results[,which(!grepl(\"^-log10\",colnames(results)))]\n  results<-results[,which(!grepl(\"sd$\",colnames(results)))]\n  results<-results[,which(!grepl(\"^nID$\",colnames(results)))]\n  results<-results[,which(!grepl(\"^diffexp\",colnames(results)))]\n  \n  #write.table(results,file=paste(outputFigsPrefix,\"_results_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",col.names=NA)\n  \n  quant_species<-\"proteins\"\n  if(!ProteinQuantitation){\n    quant_species<-\"peptides\"\n  }  \n  n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n  n_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n  if(n_bioreps>1){\n    cat(paste(\"do_results_plots: Quantified \",quant_species,\" (>2 peptides/\",n_techreps,\" injection(s) in at least \",nRequiredLeastBioreps,\" replicates): \",nrow(results),\" (\",time.point,\")\\n\",sep=\"\"))\n  }else{\n    cat(paste(\"do_results_plots: Quantified \",quant_species,\" (>2 peptides/\",n_techreps,\" injection(s)): \",nrow(results),\" (\",time.point,\")\\n\",sep=\"\"))\n  }  \n  \n  for(i in 1:nrow(ratio_combs)){\n\tcol_desc_<-paste(\"P-value adjusted \",paste(conditions.labels[ratio_combs[i,2]],\"/\",conditions.labels[ratio_combs[i,1]],sep=\"\"),sep=\"\")\n\tndiffexp_tmp<-length(which(results[,col_desc_]<0.05))\n\tcat(paste(\"do_results_plots: Differentially expressed for \",conditions.labels[ratio_combs[i,2]],\" vs \",conditions.labels[ratio_combs[i,1]],\" : \",ndiffexp_tmp,\"\\n\",sep=\"\"))\n  }\n  cat(paste(\"do_results_plots: Differentially expressed in at least one combination of conditions: \",ndiffexp,\"\\n\",sep=\"\"))\n  \n  diffexp<-results[,c(grep(\"^P-value adjusted\",colnames(results)),grep(\"avg log2 [^I]+\",colnames(results)),grep(\"sd log2 \",colnames(results)),grep(\"N log2 \",colnames(results)),grep(\"avg log2 I \",colnames(results)))]\n  diffexp[,quantitated_items_lbl]<-rownames(diffexp)\n    \n  diffexp<-diffexp[,c(grep(quantitated_items_lbl,colnames(diffexp)),grep(\"avg log2 [^I]+\",colnames(diffexp)),grep(\"log2 sd \",colnames(diffexp)),grep(\"P-value \",colnames(diffexp)), grep(\"log2 N \",colnames(diffexp)),grep(\"log2 avg I \",colnames(diffexp)))]\n  tmp_protein_groups<-protein_groups\n  colnames(tmp_protein_groups)[grep(paste(quantitated_items_lbl,\".IDs\",sep=\"\"),colnames(tmp_protein_groups))]<-quantitated_items_lbl\n  diffexp<-merge(diffexp,tmp_protein_groups[,c(quantitated_items_lbl,sort(colnames(tmp_protein_groups)[grep(\"Ratio\\\\.counts\",colnames(tmp_protein_groups))]))],by=quantitated_items_lbl,all.x=T)\n  diffexp$newcol<-rowSums(diffexp[,colnames(diffexp)[grep(\"Ratio\\\\.counts\",colnames(diffexp))]],na.rm=T)\n  colnames(diffexp)[length(colnames(diffexp))]<-\"Ratio.counts.total\"  \n  \n  signTruth<-rep(FALSE,nrow(diffexp))\n  col_desc_<-grep(\"P-value \",colnames(diffexp))\n  for(cond_i_col in col_desc_){\n    na_indexes<-which(is.na(diffexp[,cond_i_col]))\n    if(length(na_indexes)>0){\n      diffexp[na_indexes,cond_i_col]<-1\n      signTruth<-(signTruth | diffexp[,cond_i_col]<0.05)\n      diffexp[na_indexes,cond_i_col]<-NA\n    }else{\n      signTruth<-(signTruth | diffexp[,cond_i_col]<0.05)\n    }    \n  }\n  \n  colnames(diffexp)<-gsub(\"\\\\.\",\" \",colnames(diffexp))\n  \n  if(!ProteinQuantitation){\n    diffexp<-merge(diffexp,protein_groups[c(\"Peptide.IDs\",\"Protein.IDs\")],by.x=c(\"Peptide\"),by.y=c(\"Peptide.IDs\"),all.x=T)\n    colnames(diffexp)[grep(\"^Protein\\\\.IDs$\",colnames(diffexp))]<-\"Protein\"\n  }\n  dec <- \",\"\n  if(grepl(\"(English|Thai)\",Sys.getlocale())){\n    dec <- \".\"\n  }\n  write.table(diffexp[signTruth,],dec=dec,file=paste(outputFigsPrefix,\"_diffexp_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F,quote=F)\n  \n  diffexp<-merge(diffexp,results[,-grep(\"^(avg log2|P-value adjusted)\",colnames(results))],by.x=c(quantitated_items_lbl),by.y=c(\"ID\"),all.x=T)\n  write.table(diffexp,dec=dec,file=paste(outputFigsPrefix,\"_results_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F,quote=F)\n  \n  levellog(\"\",change=-1)\n  return(results)\n}\n\n# Performs the differential expression analysis through limma, after quantile normalization.\ndo_limma_analysis<-function(working_pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n\tlevellog(\"\",change=1)\n\t\n\tlevellog(\"Preparing limma input data frame ...\")\n\t# Read the sample key\n\t# Assigns sample names (from the data file) to groups\n\t# Sample order must be the same as the main data file, but excludes technical\n\t# replicates as we will aggregate into one value per sample.\n\tsample.key <- read.delim(exp_design_fname, header=TRUE,row.names=1,colClasses=\"character\")\n  sample.key$Category <- factor(sample.key$Category, levels=unique(sample.key$Category))\n\t\n\t# Extract protein/peptide quantitation columns only from quantitation input file\n\t# The quantitation data is in columns 10 to 90.\n\n\t#prot.intensities <- quantitation[,10:90]\n\tprot.intensities <- working_pgroups\n\n\t# Extract the protein names/peptide sequences (imported from the data file) into a\n\t# separate list for future reference\n\n\tprot.names <- rownames(prot.intensities)\n\n\t# Take log2 of intensities\n\n\tlog.intensities  <- log2(prot.intensities)\n\n\tsetwd(limma_output)\n\t\n\tlevellog(\"Saving limma input frame ...\")\n\twrite.table(working_pgroups,file=paste(outputFigsPrefix,\"_limma-input_\",quantitated_items_lbl,\"Groups.txt\",sep=\"\"),sep=\"\\t\",row.names = T, col.names=NA)\n\n\tif(exportFormat == \"pdf\"){\n\t\tpdf(file=paste(outputFigsPrefix,\"_limma-graphs_\",time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n\t}\n\t# Box plot before normalisation\n\tboxplot(log.intensities)\n\ttitle(main=\"Intensities Before Normalisation\")\n\n\t# Perform quantile normalisation\n\tlevellog(\"Performing quantile normalisation ...\")\n\tnorm.intensities <- normalizeBetweenArrays(data.matrix(log.intensities), method=\"quantile\");\n\n\t# Box plot after normalisation\n\tboxplot(norm.intensities)\n\ttitle(main=\"Intensities After Normalisation\")\n\n\tnorm.median.intensities<-as.data.frame(t(as.matrix(norm.intensities)))\n\n\t# Assign row names to our aggregated intensities from the sample key\n\n\trow.names(norm.median.intensities) <- row.names(sample.key)\n\n\t# Setup design matrix\n\t# This specifies the design of the experiment for limma, replicating\n\t# the info in the sample key, but representing it in a matrix format\n\tlevellog(\"Constructing the design matrix ...\")\n\tdesign <- model.matrix(~0 + factor(sample.key$Category))\n\tcolnames(design) <- levels(sample.key$Category)\n\twrite.table(design,file=paste(outputFigsPrefix,\"_limma-design-matrix_\",quantitated_items_lbl,\"Groups.txt\",sep=\"\"),sep=\"\\t\",row.names = T, col.names=NA)\n\twrite.table(rep_structure,file=paste(outputFigsPrefix,\"_limma-blocking-variable_\",quantitated_items_lbl,\"Groups.txt\",sep=\"\"),sep=\"\\t\",row.names = T, col.names=NA)\n\tfit<-\"\"\n\tn_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n\tn_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n\t\n\tlevellog(\"Fitting the model ...\")\n  if(n_bioreps > 1 & n_techreps > 1){\n\t\t# technical replication specification\n\t\tcorfit <- duplicateCorrelation(t(norm.median.intensities), design=design, block = rep_structure, trim = duplicateCorrelation_trim)\n\t\t# Fit the limma model to the data\n\t\t# Pass the protein names/peptide sequences to limma as the genes option\n\t\tfit <- lmFit(t(norm.median.intensities), design, genes=prot.names, block = rep_structure, cor = corfit$consensus)\n\t}else{\n\t\tfit <- lmFit(t(norm.median.intensities), design, genes=prot.names)\n\t}\n\n\t# Setup contrast matrix\n\t# The contrast matrix specifies what comparisons we want to make between groups.\n\t# We pass the design matrix as the levels option to the makeContrasts function.\n\t\n\tlevellog(\"Constructing the contrast matrix ...\")\n\tratio_combs<-combinations(nConditions,2,1:nConditions)\n\tcontrasts<-c()\n\tfor(i in 1:nrow(ratio_combs)){\n\t  contrasts<-c(contrasts,paste(conditions.labels[ratio_combs[i,2]],\"-\",conditions.labels[ratio_combs[i,1]],sep=\"\"))\n\t}\n\tcontrasts <- makeContrasts(contrasts=contrasts, levels=design)\n\twrite.table(contrasts,file=paste(outputFigsPrefix,\"_limma-contrasts-matrix_\",quantitated_items_lbl,\"Groups.txt\",sep=\"\"),sep=\"\\t\",row.names = T, col.names=NA)  \n\t# Apply contrast matrix and do empirical bayes analysis to get p-values etc.\n\t\n\tlevellog(\"Performing hypothesis testing ...\")\n\tfit2 <- contrasts.fit(fit, contrasts)\n\tfit2 <- eBayes(fit2)\n\n\t# Make volcano plot\n\n\t#volcanoplot(fit2, highlight=\"20\")\n\t#title(main=\"Log odds vs fold change STIMULATED-CTRL\", sub=\"Top 20 most significant proteins highlighted\")\n\n\t# Plot a Histogram of co-efficients (log2 ratio)\n\tfor(i in 1:nrow(ratio_combs)){\n\t  ratio_i_str<-paste(conditions.labels[ratio_combs[i,2]],\"/\",conditions.labels[ratio_combs[i,1]],sep=\"\")\n\t  hist(fit2$coefficients[,i],main=paste(\"Log2 Fold Change \",ratio_i_str,sep=\"\"), xlab=\"Log2 Fold Change\", breaks=50 )\n\t}   \n\t\n\t\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_limma-graphs_\",time.point,\"_hist.emf\",sep=\"\"),type=\"emf\")\n\t}\n\n\t# Do an MA Plot (mean of log2 intensities vs log2 ratio)\n\t# Important to inspect the MA plot to ensures that the ratio does not depend on\n\t# the intensity of the protein/peptide. This shouldn't happen if the data was normalised\n\t# successfully, and should be unusual in SILAC / label-free experiments.\n\t#for(i in 1:nrow(ratio_combs)){\n\t#  plotMA(fit2)\n\t  \n\t  # Add a line at y=0 to the MA plot. The clouds of points should be centred around y=0\n\t  # if most proteins/peptides are unchanges and normalisation worked well.\n\t  \n\t#  abline(h=0)\n\t  \n\t#  if(exportFormat == \"emf\"){\n\t#    savePlot(filename=paste(outputFigsPrefix,\"_limma-graphs_\",time.point,\"_MA.emf\",sep=\"\"),type=\"emf\")\n\t#  }\n\t#}\n  \n\tdev.off()\n\n\t# Output analysis details to file\n\t# asjust=\"BH\" means adjust the calculated p-values for multiple testing using\n\t# the Benjamini Hochberg method (FDR)\n\tlevellog(\"Saving analysis results to file ...\")\n\twrite.fit(fit2, file=paste(outputFigsPrefix,\"_condition-i_vs_condition-j_\",time.point,\".txt\",sep=\"\"), adjust=\"BH\")\n\n\tnorm.median.intensities<<-norm.median.intensities #for debugging purposes\n  \n\tlevellog(\"Generating analysis plots ...\")\n\tresults<-do_results_plots(norm.median.intensities, time.point, exportFormat=exportFormat,outputFigsPrefix=outputFigsPrefix)\n\tsetwd(\"..\")\n\t\n\tlevellog(\"\",change=-1)\n\treturn(results)\n}\n\n# Reads MaxQuant (1.3.0.5) proteinGroups table, discards information not required (for downstream analysis) and returns the table\nread.pgroups_v2<-function(fname,evidence_fname, time.point,generateVenns=T){\n  pgroups<-read.table(fname, header = T, sep = \"\\t\",quote='',stringsAsFactors = FALSE,comment.char=\"\")\n  mq_labels_names<-unique(sub(\"^Intensity\\\\.([^\\\\.]+)\\\\..+$\",\"\\\\1\",colnames(pgroups)[grep(\"^Intensity\\\\.([^\\\\.]+)\\\\..+$\",colnames(pgroups))]))\n  evidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors = FALSE,comment.char=\"\")\n  \n  pgroups<-pgroups[pgroups$Reverse != \"+\" & pgroups$Contaminant != \"+\", ]\n\tpgroups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.IDs),\" ...]\",sep=\"\")\n\n  cat(paste(\"read.pgroups_v2: Identified proteins (w/o contaminants): \",nrow(pgroups),\" (\",time.point,\")\\n\",sep=\"\"))\n  \n\tpgroups_evidence<-as.data.frame(do.call(rbind,apply(cbind(as.character(pgroups$id),pgroups$Evidence.IDs),1,function(x) cbind(x[1],unlist(strsplit(x[2],\";\"))))),stringsAsFactors=F)\n  colnames(pgroups_evidence)<-c(\"id\",\"Evidence.IDs\")\n\tpgroups_evidence$id<-as.numeric(pgroups_evidence$id)\n\tpgroups_evidence$Evidence.IDs<-as.numeric(pgroups_evidence$Evidence.IDs)\n  \n  evidence_labels_intensity_cols<-paste(\"Intensity.\",mq_labels_names,sep=\"\")\n  evidence_sequences<-evidence[,c(\"id\",\"Sequence\",\"Raw.file\",\"Labeling.State\",\"Modifications\", evidence_labels_intensity_cols)]\n  colnames(evidence_sequences)[1:5]<-c(\"Evidence.IDs\",\"Sequence\",\"Spectrum.File\",\"Labeling.State\", \"Modifications\")\n\tpgroups_evidence<-merge(pgroups_evidence,evidence_sequences,by=\"Evidence.IDs\",all.x=T)\n  pgroups_evidence<-merge(pgroups_evidence,pgroups[,c(\"id\",\"Protein.IDs\")],by=\"id\",all.x=T)\n  pgroups_evidence<-pgroups_evidence[,-1]\n    \n  #Count the number of peptide labels (unique combination of peptide sequence and labeling state) per protein and replicate\n  subtotals<-ddply(pgroups_evidence,c(\"Protein.IDs\"),function(x){\n    cond_lengths<-c()\n    for(cond_i in conditions.labels){\n      x_idxs<-which(x$Labeling.State==(which(cond_i==conditions.labels)-1))\n      x$lab_seq<-paste(x$Labeling.State,x$Sequence,sep=\"_\")\n      cond_lengths<-cbind(cond_lengths, length(unique(x[x_idxs,c(\"lab_seq\")])))\n    }\n    ret<-data.frame(cond_lengths)\n    colnames(ret)<-conditions.labels\n    return(ret)\n  })\n  \n  #Calculate the respective percentages\n  for(label_i in conditions.labels){\n    subtotals$newcol<-apply(subtotals,1,function(x){\n      row_subtotals<-as.numeric(x[-1])\n      if(sum(row_subtotals) == 0){\n        return(0)\n      }else{\n        return(100*(row_subtotals[which(label_i==conditions.labels)]/sum(row_subtotals)))\n      }\n    })\n    colnames(subtotals)[length(colnames(subtotals))]<-paste(label_i,\"p\",sep=\"\")\n  }  \n  \n  if(ProteinQuantitation){\n    #Count the number of peptide sequences per protein and replicate\n    subtotals2<-ddply(pgroups_evidence,c(\"Spectrum.File\",\"Protein.IDs\"),function(x){\n      uniqueSequences<-length(unique(x$Sequence))\n      ret<-data.frame(cbind(uniqueSequences))\n      colnames(ret)<-c(\"uniqueSequences\")\n      return(ret)\n    })\n  }else{\n    #Calculate peptide intesity per label and per replicate\n    #Warning: Contrary to PD data, here we don't peptide uniqueness information, so one peptide might\n    # correspond to more than one protein IDs\n    subtotals2<-ddply(pgroups_evidence,c(\"Spectrum.File\",\"Sequence\",\"Modifications\"),function(x){\n      cond_sums<-c()\n      for(cond_i in evidence_labels_intensity_cols){\n        cond_sums<-cbind(cond_sums, sum(x[,cond_i],na.rm=T))\n      }\n      cond_counts<-sum(!is.na(x[,evidence_labels_intensity_cols[1]])) # It doesn't matter which label is used for counting. This is the ratio counts, and since PD replaces missing signlas with the minimum intensity, there will always be a ratio, and the number of ratios will be equal to the number of records here. Unwanted ratios, such as those that are equal to 1 and should not be considered/counted are filtered above, at the peptide-filtering stage if chosen by the user (recommended)\n      ret<-data.frame(cbind(cond_sums,cond_counts))\n      colnames(ret)<-c(paste(\"Intensity.\",mq_labels_names,sep=\"\"),\"Ratio.counts\")\n      ret$Evidence.IDs<-paste(x$Evidence.IDs,collapse=\";\")\n      ret$Sequence<-toupper(x$Sequence[1])\n      ret$Protein.IDs<-paste(unique(x$Protein.IDs),collapse=\";\") # maybe more than on protein IDs, so we have to collapse\n      ret$nProteins<-length(unique(x$Protein.IDs))\n      return(ret)    \n    })\n    #discard peptides that belong to more than one protein (i.e. non-unqiue)\n    subtotals2<-subtotals2[subtotals2$nProteins<2,]\n    subtotals2<-subtotals2[,!colnames(subtotals2) %in% \"nProteins\"]\n    # Remove peptides that are not of interest (conditions.Mod is not empty means the user wants peptides with certain modifications only)\n    if(!ProteinQuantitation && length(conditions.Mods)>0){\n      for(i in 1:length(conditions.Mods)){\n        for(mod_i_mods in conditions.Mods.Modifications[[i]]){\n          #strip modification from parentheses and escape characters\n          mod_i_mods<-sub(\"\\\\\\\\\",\"\",mod_i_mods)\n          mod_i_mods<-sub(\")$\",\"\",mod_i_mods)\n          subtotals2<-subtotals2[grepl(mod_i_mods,subtotals2$Modifications),]\n        }\n      } \n    }\n  }\n  #Re-arrange data and assign column names\n  if(ProteinQuantitation){\n    melted_subtotals<-melt(subtotals2)\n  }else{\n    melted_subtotals<-melt(subtotals2,id.vars=c(\"Spectrum.File\", \"Sequence\", \"Modifications\", \"Evidence.IDs\",\"Protein.IDs\"))\n  }\n  \n\tn_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n\tn_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]\n\t\n\tmelted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n\t\n\trep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/nConditions)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\tif(!is.na(rep_order)){\n\t  o<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n\t  rep_desc<-rep_desc[o]\n\t}\n\t\n\tlevels(melted_subtotals$Spectrum.File)<-rep_desc\n  \n\tif(ProteinQuantitation){\n\t  pgroups_uniqueSequences<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) x))\n\t}else{\n\t  pgroups_uniqueSequences<-as.data.frame(tapply(melted_subtotals$value,list(Peptide.IDs=paste(melted_subtotals$Sequence,\" [\",melted_subtotals$Modifications,\"]\",sep=\"\"),RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n\t}\n  \n\tpgroups_uniqueSequences[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]<-row.names(pgroups_uniqueSequences)\n  \n  if(ProteinQuantitation){\n\t  if(keepEvidenceIDs){\n\t  \tpgroups<-merge(pgroups_uniqueSequences, pgroups[,c(\"Protein.IDs\",sort(colnames(pgroups)[grep(\"Ratio\\\\..*\\\\.count.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Intensity\\\\..*\\\\.b\",colnames(pgroups))]),\"Evidence.IDs\")],by=\"Protein.IDs\",all.x=T)\n\t  }else{\n\t  \tpgroups<-merge(pgroups_uniqueSequences, pgroups[,c(\"Protein.IDs\",sort(colnames(pgroups)[grep(\"Ratio\\\\..*\\\\.count.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Intensity\\\\..*\\\\.b\",colnames(pgroups))]))],by=\"Protein.IDs\",all.x=T)\n\t  }\n  }else{\n    subtotals2$Peptide.IDs<-paste(subtotals2$Sequence,\" [\",subtotals2$Modifications,\"]\",sep=\"\")\n    #pgroups_evidence$Peptide.IDs<-paste(pgroups_evidence$Sequence,\" [\",pgroups_evidence$Modifications,\"]\",sep=\"\")\n    #subtotals2<-merge(subtotals2, unique(pgroups_evidence[,c(\"Peptide.IDs\",\"Protein.IDs\")]),by=\"Peptide.IDs\",all.x=T)\n    #if(keepEvidenceIDs){\n    #  pgroups<-merge(pgroups_uniqueSequences, unique(subtotals2[,c(\"Peptide.IDs\",\"Protein.IDs\",\"Evidence.IDs\")]),by=\"Peptide.IDs\",all.x=T)\n    #}else{\n      pgroups<-merge(pgroups_uniqueSequences, unique(subtotals2[,c(\"Peptide.IDs\",\"Protein.IDs\")]),by=\"Peptide.IDs\",all.x=T)\n    #}    \n  }\n\t#For razor-unique peptide column: replace the triple-dot R replaces the MaxQuant column name with\n  #colnames(pgroups)<-sub(\"\\\\.\\\\.\\\\.\",\"\\\\.\",colnames(pgroups)) \n\t#colnames(pgroups)<-sub(\"Ratio.([^\\\\.]+)\\\\.([^\\\\.]+)\\\\.count\\\\.(.*)\",\"\\\\3.Ratio.counts.\\\\1.\\\\2\",colnames(pgroups))  \n  #pgroups<-merge(pgroups,subtotals,by=\"Protein.IDs\",all.x=T)\n  \n  if(ProteinQuantitation){\n    colnames(pgroups)[grep(\"^Ratio.[^\\\\.]+\\\\.[^\\\\.]+\\\\.count\\\\.\",colnames(pgroups))]<-sub(\"^Ratio.([^\\\\.]+)\\\\.([^\\\\.]+)\\\\.count\\\\.(.+)$\",\"\\\\3.\\\\1.\\\\2.Ratio.counts\",colnames(pgroups)[grep(\"^Ratio.[^\\\\.]+\\\\.[^\\\\.]+\\\\.count\\\\.\",colnames(pgroups))])\n    for(i in 1:length(conditions.labels)){\n      colnames(pgroups)[grep(\"^Intensity\\\\.\",colnames(pgroups))]<-sub(paste(\"^Intensity\\\\.(\",mq_labels_names[i],\")\\\\.\",sep=\"\"),paste(\"Intensity.\",conditions.labels[i],\".\",sep=\"\"),colnames(pgroups)[grep(\"^Intensity\\\\.\",colnames(pgroups))])\n    }    \n  }else{\n    for(i in 1:length(conditions.labels)){\n       colnames(pgroups)[grep(paste(\"^[^\\\\.]+\\\\.Intensity\\\\.\",mq_labels_names[i],\"$\",sep=\"\"),colnames(pgroups))]<-sub(paste(\"^([^\\\\.]+)\\\\.Intensity\\\\.\",mq_labels_names[i],\"$\",sep=\"\"),paste(\"Intensity.\",conditions.labels[i],\".\\\\1\",sep=\"\"),colnames(pgroups)[grep(paste(\"^[^\\\\.]+\\\\.Intensity\\\\.\",mq_labels_names[i],\"$\",sep=\"\"),colnames(pgroups))])\n    }    \n  }\n  \n  if(ProteinQuantitation){\n    #Retain only first combination of labels for Ratio.counts columns (others have same counts)\n    #WARNING: Maybe this is not correct if MQ is used with 're-quantify' disabled \n    if(nConditions > 2){\n      pgroups_rest<-pgroups[,-grep(\"Ratio\\\\.counts$\",colnames(pgroups))]\n      pgroups<-cbind(pgroups_rest, pgroups[,grep(\"Ratio\\\\.counts$\",colnames(pgroups))[1:(n_bioreps*n_techreps)]])\n    }\n    colnames(pgroups)[grep(\"Ratio\\\\.counts$\",colnames(pgroups))]<-sub(\"^([^\\\\.]+)\\\\.[^\\\\.]+\\\\.[^\\\\.]+\\\\.Ratio\\\\.counts\",\"\\\\1.Ratio.counts\",colnames(pgroups)[grep(\"Ratio\\\\.counts$\",colnames(pgroups))])\n  }\n  row.names(pgroups)<-pgroups[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]\n  \n  #\n  if(generateVenns){\n    setwd(limma_output)\n    venn_data<-id_Venn3_pgroups(pgroups)\n    write.table(venn_data,file=paste(outputFigsPrefix,\"_id_venn3-data_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n    setwd(\"..\")\n  }\n  #\n  \n  if(ProteinQuantitation){\n    #Remove proteins with total ratio count of 0 (not quantifiable)\n    pgroups<-pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Ratio\\\\.counts\",colnames(pgroups))]],na.rm=T)>0,]\n    #Integrate percentage labeling information\n    pgroups<-merge(pgroups,subtotals,by=\"Protein.IDs\",all.x=T)\n    #If enabled, do filter out proteins based on percentage labeling for the desited label\n    if(filterL && !filterL_lvl){\n      fl<-paste(filterL_lbl,\"p\",sep=\"\")\n      pgroups<-pgroups[pgroups[,c(fl)]<100,]\n    }\n  }\n  \n  pgroups$time.point<-time.point\n  \n  quant_species<-\"proteins\"\n  if(!ProteinQuantitation){\n    quant_species<-\"peptides\"\n  }  \n  \n  cat(paste(\"read.pgroups_v2: Quantifiable \",quant_species,\" (w/o contaminants): \",nrow(pgroups),\" (\",time.point,\")\\n\",sep=\"\"))\n\n  if(generateVenns){\n    setwd(limma_output)\n    venn_data<-quant_Venn3_pgroups(pgroups_filter_2reps_v2(pgroups,time.point))\n    write.table(venn_data,file=paste(outputFigsPrefix,\"_quant_venn3-data-2reps_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n    setwd(\"..\")  \n  }\n  \n\treturn(pgroups)\n}\n\n## PATCHED -- number of conditions/labels-indpendent function\n# Like the (see) above function, but without protein grouping.\nid_Venn3_pgroups_PD<-function(fname,evidence_fname,time.point,rep_structure,filterL=F,rep_order=NA){\n  evidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n  #Generate Evidence ID\n  evidence$id<-1:(nrow(evidence))\t\n  allproteins<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions),length))\n  allproteins<-data.frame(Protein.IDs=names(allproteins[[1]]),stringsAsFactors=F)\n  \n  tmpdf<-evidence[,c(\"Protein.Group.Accessions\",\"Protein.Descriptions\")]\n  colnames(tmpdf)<-c(\"Protein.IDs\",\"Protein.Descriptions\")\n  tmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]\n  allproteins<-merge(allproteins,tmpdf,by=\"Protein.IDs\",all.x=T)\n  \n  tmp<-sub(\"^([^;]*).*\",\"\\\\1\",allproteins$Protein.IDs)\n  tmp1<-unlist(lapply(allproteins$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n  \n  allproteins$Protein.Group.Accessions<-allproteins$Protein.IDs   #keep old IDs\n  allproteins$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n  allproteins$Protein.IDs<-paste(allproteins$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n  allproteins<-allproteins[!duplicated(allproteins$Protein.IDs),]\n  \n  #cat(paste(\"Identified proteins: \",nrow(allproteins),\" (\",time.point,\")\",sep=\"\"))\n  \n  \n  evidence<-merge(evidence,allproteins,by=\"Protein.Group.Accessions\",all.x=T)\n  evidence$Spectrum.File<-factor(evidence$Spectrum.File)\n  \n  if(ProteinQuantitation){\n    #Count unique peptide sequences per protein and replicate\n    subtotals2<-ddply(evidence,c(\"Spectrum.File\",\"Protein.IDs\"),function(x){\n      ids<-paste(x$id,collapse=\";\")\n      ret<-data.frame(cbind(ids))\n      colnames(ret)<-c(\"Evidence.IDs\")\n      nUniqueSequences<-length(unique(x$Unique.Sequence.ID))\n      ret$uniqueSequences<-nUniqueSequences\n      return(ret)\n    })\n    all_evidence_ids<-ddply(subtotals2,c(\"Protein.IDs\"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=\";\")))\n  }else{\n    #Count unique peptide sequences per replicate\n    #First, We have to remove the labels from the modifications column, because we have to pivot on modifications but not on labels\n    modcol<-evidence$Modifications\n    for(i in 1:length(conditions.labels)){\n      for(mod_i in conditions.labels.Modifications[[i]]){\n        if(mod_i != \"\"){\n          modcol<-gsub(paste(\"[A-Z]+[0-9]+\\\\(\",mod_i,\"[; ]*\",sep=\"\"),\"\",modcol)\n        }\n      }\n    }\n    modcol<-gsub(\"^[ ]+\",\"\",modcol)\n    modcol<-gsub(\";[ ]+$\",\"\",modcol)\n    evidence[,\"Modifications.only\"]<-modcol    \n    \n    subtotals2<-ddply(evidence,c(\"Spectrum.File\",\"Unique.Sequence.ID\",\"Modifications.only\"),function(x){\n      ids<-paste(x$id,collapse=\";\")\n      ret<-data.frame(cbind(ids))\n      colnames(ret)<-c(\"Evidence.IDs\")\n      ret$Sequence<-toupper(x$Sequence[1])\n      return(ret)\n    })\n  }\n  \n  #Re-arrange data and assign column names\n  if(ProteinQuantitation){\n    melted_subtotals<-melt(subtotals2)\n  }else{\n    melted_subtotals<-melt(subtotals2,id.vars=c(\"Spectrum.File\", \"Sequence\", \"Modifications.only\", \"Evidence.IDs\"))\n  }\n  \n  #write.table(tmp,file=\"tmp.txt\",row.names=F,sep=\"\\t\")\n  #write.table(evidence,file=\"tmp2.txt\",row.names=F,sep=\"\\t\")\n  \n  n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n  n_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n  i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]\n  \n  melted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n  \n  rep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/nConditions)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n  if(!is.na(rep_order)){\n    o<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n    rep_desc<-rep_desc[o]\n  }\n  \n  if(LabelFree){\n    tmp_rep_desc<-c()\n    for(i in 1:nConditions){\n      tmp_rep_desc[[i]]<-paste(\"c\",i,rep_desc,sep=\"\")\n      levels(melted_subtotals$Spectrum.File)[which(levels(melted_subtotals$Spectrum.File) %in% paste(conditions.labels.Modifications[[i]],\".raw\",sep=\"\"))]<-tmp_rep_desc[[i]]\n    }\n    rep_desc<-unlist(tmp_rep_desc)\n    melted_subtotals$brtr<-NA\n    biorep_techrep<-regmatches(levels(melted_subtotals$Spectrum.File), regexpr(\"b.*\", levels(melted_subtotals$Spectrum.File)))\n    for(i in 1:length(levels(melted_subtotals$Spectrum.File))){\n      lvl_i<-levels(melted_subtotals$Spectrum.File)[i]\n      brtr<-biorep_techrep[i]\n      melted_subtotals[melted_subtotals$Spectrum.File == lvl_i,\"brtr\"]<-brtr\n    }\n    melted_subtotals$brtr<-factor(melted_subtotals$brtr)\n  }else{\n    levels(melted_subtotals$Spectrum.File)<-rep_desc\n  }\n  \n  if(ProteinQuantitation){\n    if(LabelFree){\n      pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$brtr,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n    }else{\n      pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n    }    \n  }else{\n    pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Peptide.IDs=paste(melted_subtotals$Sequence,\" [\",melted_subtotals$Modifications.only,\"]\",sep=\"\"),RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) length(x)))\n    pgroups[is.na(pgroups)]<-0\n  }\n\n  pgroups[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]<-row.names(pgroups)\n\n  if(keepEvidenceIDs && ProteinQuantitation)\n  {\n    pgroups<-merge(pgroups,all_evidence_ids,by=\"Protein.IDs\",all.x=T)\n  }\n  \n  # Remove peptides that are not of interest (conditions.Mod is not empty means the user wants peptides with certain modifications only)\n  if(!ProteinQuantitation && length(conditions.Mods)>0){\n    for(i in 1:length(conditions.Mods)){\n      for(mod_i_mods in conditions.Mods.Modifications[[i]]){\n        pgroups<-pgroups[grepl(mod_i_mods,pgroups$Peptide.IDs),]\n      }\n    }    \n  }\n  \n  if(ProteinQuantitation){\n    #pgroups<-pgroups[,!(colnames(pgroups) %in% c(\"Protein.Descriptions\"))]\n    #cat(paste(\"id_Venn3_pgroups_PD: Identified proteins: \",nrow(pgroups),\" (\",time.point,\")\\n\",sep=\"\"))\n  }else{\n    cat(paste(\"id_Venn3_pgroups_PD: Peptide modified sequences: \",nrow(pgroups),\" (\",time.point,\")\\n\",sep=\"\"))\n  }\n  \n  row.names(pgroups)<-pgroups[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]\n\t\n\tvenn_data<-c()\n  for(brep_i in 1:n_bioreps){\n    if(n_techreps>1){\n      b_i<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(paste(\"b\",brep_i,sep=\"\"),colnames(pgroups))]],na.rm=T)>0,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"))],stringsAsFactors=F)\n      b_i$rep<-as.character(brep_i)\n      venn_data<-rbind(venn_data,b_i)\n    }else{\n      b_i_col<-colnames(pgroups)[grep(paste(\"b\",brep_i,sep=\"\"),colnames(pgroups))]\n      b_i<-data.frame(Protein.IDs=pgroups[!is.na(pgroups[,b_i_col]) & pgroups[,b_i_col]>0,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"))],stringsAsFactors=F)\n      b_i$rep<-as.character(brep_i)\n      venn_data<-rbind(venn_data,b_i)\n    }\n  }\n  colnames(venn_data)[1]<-paste(quantitated_items_lbl,\".IDs\",sep=\"\")\n\treturn(venn_data)\n}\n\n#Like the above, but for MaxQuant data\nid_Venn3_pgroups<-function(pgroups){\n  n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n  n_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n  i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]  \n  \n  if(ProteinQuantitation){\n    pgroups<-pgroups[,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"),colnames(pgroups)[grep(\"uniqueSequences$\",colnames(pgroups))])]\n  }\n  venn_data<-c()\n  for(brep_i in 1:n_bioreps){\n    if(n_techreps>1){\n      b_i<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(paste(\"b\",brep_i,sep=\"\"),colnames(pgroups))]],na.rm=T)>0,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"))],stringsAsFactors=F)\n      b_i$rep<-as.character(brep_i)\n      venn_data<-rbind(venn_data,b_i)\n    }else{\n      b_i_col<-colnames(pgroups)[grep(paste(\"b\",brep_i,sep=\"\"),colnames(pgroups))]\n      b_i<-data.frame(Protein.IDs=pgroups[!is.na(pgroups[,b_i_col]) & pgroups[,b_i_col]>0,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"))],stringsAsFactors=F)\n      b_i$rep<-as.character(brep_i)\n      venn_data<-rbind(venn_data,b_i)\n    }\n  }\n  colnames(venn_data)[1]<-paste(quantitated_items_lbl,\".IDs\",sep=\"\")\n\treturn(venn_data)\n}\n\n## PATCHED -- number of conditions/labels-indpendent function\n#Like the above, but for quantified proteins (quantified means having a Ratio.H.M.count greater than 0 for each replicate.\nquant_Venn3_pgroups<-function(pgroups){\n  \n  n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n  n_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n  i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]\n  \n  pgroups<-pgroups[,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"),colnames(pgroups)[grep(\"\\\\.Ratio\\\\.counts$\",colnames(pgroups))])]\n  \n  venn_data<-c()\n    for(brep_i in 1:n_bioreps){\n      if(n_techreps>1){\n        b_i<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(paste(\"^b\",brep_i,sep=\"\"),colnames(pgroups))]], na.rm=T) > 0,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"))],stringsAsFactors=F)\n        b_i$rep<-as.character(brep_i)\n        venn_data<-rbind(venn_data,b_i)\n      }else{\n        b_i_col<-colnames(pgroups)[grep(paste(\"^b\",brep_i,sep=\"\"),colnames(pgroups))]\n        b_i<-data.frame(Protein.IDs=pgroups[!is.na(pgroups[,b_i_col]) & pgroups[,b_i_col]>0,c(paste(quantitated_items_lbl,\".IDs\",sep=\"\"))],stringsAsFactors=F)\n        b_i$rep<-as.character(brep_i)\n        venn_data<-rbind(venn_data,b_i)\n      }\n    }\n  colnames(venn_data)[1]<-paste(quantitated_items_lbl,\".IDs\",sep=\"\")\n\n\treturn(venn_data)\n}\n\n\n# MaxQuant (1.3.0.5) only\n# Like the above, apart from the quant filter.\n# Quantified proteins using this function will be considered only those with a total Ratio.H.M.count > 2 for at least two replicates\n#TODO: generalize for any replicate structure for the identified proteins, as it now assumes 3 biological x 3 technical replicates (nested)\ndo_generate_Venn3_data_quant_filter_2reps<-function(pgroups,time.point,outputFigsPrefix=\"\"){\n\tsetwd(limma_output)\n\t#venn_data<-quant_Venn3_pgroups(pgroups[pgroups$time.point == time.point,])\n\tvenn_data<-quant_Venn3_pgroups(pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,],time.point))\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_quant_venn3-data-2reps_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tvenn_data<-id_Venn3_pgroups(pgroups[pgroups$time.point == time.point,])\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_id_venn3-data_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tsetwd(\"..\")\n}\n\n# Like the above, but for PD (1.3)\ndo_generate_Venn3_data_quant_filter_2reps_PD<-function(pgroups,time.point,evidence_fname,rep_structure,rep_order=NA,outputFigsPrefix=\"\"){\n  venn_data<-id_Venn3_pgroups_PD(\"\",evidence_fname,time.point,rep_structure,rep_order)\n\tsetwd(limma_output)\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_id_venn3-data_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n  venn_data<-quant_Venn3_pgroups(pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,],time.point))\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_quant_venn3-data-2reps_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tsetwd(\"..\")\n}\n\n#More stringent quant filter, require quantitation in at least 2 replicates if bioreps>1 or in at least 2 injections if bioreps=1\npgroups_filter_2reps_v2<-function(pgroups,reps){\t#reps is dummy here\n  n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n  n_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n  i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]\n\treps_cols<-colnames(pgroups)[grep(\"Ratio\\\\.counts\",colnames(pgroups))]\n\t\n\tratioRepTruth<-c()\n\tpgroups[,reps_cols]<-apply(pgroups[,reps_cols], 2,function(x){replace(x, is.na(x), 0)})\n\t\n\tfor(rep_cols_i in i_bioreps){\n\t\tcurr_techreps_cols<-reps_cols[c(rep(rep_cols_i,n_techreps)+(0:(n_techreps-1)))]\n\t\t#ratioRepTruth<-cbind(ratioRepTruth,rowSums(pgroups[,curr_techreps_cols],na.rm=T)>2)\n\t\tif(n_techreps>1){\n        \t\tratioRepTruth<-cbind(ratioRepTruth,rowSums(pgroups[,curr_techreps_cols],na.rm=T)>2)\n      \t\t}else{\n        \t\tratioRepTruth<-cbind(ratioRepTruth,pgroups[,curr_techreps_cols]>0)\n      \t\t}\t\t\n\t}\n\tfilter<-apply(ratioRepTruth,1,function(x) length(which(x)))\n\tif(n_bioreps>1){\n    pgroups_intersect<-pgroups[filter>(nRequiredLeastBioreps-1),]\n\t}else{\n\t  pgroups_intersect<-pgroups[filter>0,]\n\t}\n\t\n\t#replace 0 with NA\n\tpgroups_intersect<-as.data.frame(lapply(pgroups_intersect, function(x){replace(x, x == 0, NA)}),stringsAsFactors = FALSE)\n\tpgroups_intersect<-as.data.frame(lapply(pgroups_intersect, function(x){replace(x, is.nan(x), NA)}),stringsAsFactors = FALSE)\n\n  quant_species<-\"proteins\"\n  if(!ProteinQuantitation){\n    quant_species<-\"peptides\"\n  }\n  #if(n_bioreps>1){\n  #  cat(paste(\"pgroups_filter_2reps_v2: Quantified \",quant_species,\" (>2 peptides/\",n_techreps,\" injection(s) in at least \",nRequiredLeastBioreps,\" replicates): \",nrow(pgroups_intersect[pgroups_intersect$time.point == time.point,]),\" (\",time.point,\")\\n\",sep=\"\"))\n  #}else{\n  #  cat(paste(\"pgroups_filter_2reps_v2: Quantified \",quant_species,\" (>2 peptides/\",n_techreps,\" injection(s)): \",nrow(pgroups_intersect[pgroups_intersect$time.point == time.point,]),\" (\",time.point,\")\\n\",sep=\"\"))\n  #}\n\treturn(pgroups_intersect)\n}\n\n#Prepare protein intensity table for differential expression analysis (the format limma requires)\nprepare_working_pgroups<-function(working_pgroups){\n\trownames(working_pgroups)<-working_pgroups[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]\n\tinten_cols<-c()\n\tfor(cond_i in conditions.labels){\n\t  inten_cols<-c(inten_cols,sort(colnames(working_pgroups)[grep(paste(\"Intensity.\",cond_i,\".b\",sep=\"\"),colnames(working_pgroups))]))\n\t}  \n\tworking_pgroups<-working_pgroups[,inten_cols]\n\tcolnames(working_pgroups)<-sub(\"Intensity\\\\.\",\"\",inten_cols)\n\treturn(working_pgroups)\n}\n\n#Perform the analysis using the more stringent quant filter (see above pgroups_filter_2reps_v2)\ndo_analyse_all_2reps_v2<-function(pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n\tlevellog(\"Filtering data based on desired reproducibility level...\",change=1)\n\tworking_pgroups<-pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,])\n\tlevellog(\"Formatting data for the statistical analysis ...\")\n\tworking_pgroups<-prepare_working_pgroups(working_pgroups)\n\toutputFigsPrefix<-paste(outputFigsPrefix,\"-all-2reps\",sep=\"\")\n\tlevellog(\"Performing the statistical analysis ...\")\n\tret<-do_limma_analysis(working_pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=outputFigsPrefix)\n\tlevellog(\"\",change=-1)\n\treturn(ret)\n}\n\n#MaxQuant (1.3.0.5) only\n#Gets rid of proteins identified just by peptides of a certain label named 'filterL_lbl'.\nfilter_unlabeled_proteins<-function(protein_groups,evidence,filterL_lbl=\"\")\n{\n\tN_proteins_before<-nrow(protein_groups)\n\tN_peptides_before<-nrow(evidence)\n\t#protein_groups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.IDs),\" ...]\",sep=\"\")\n\t#protein_groups$Protein.IDs<-gsub(\"\\\"\",\"\",protein_groups$Protein.IDs)\n\tevidence<-evidence[,c(\"id\",\"Protein.group.IDs\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error..ppm.\",\"K.Count\",\"R.Count\")]\n\tevidence<-evidence[!is.na(evidence$Labeling.State) & evidence$Labeling.State > 0,]\n\tN_peptides_after<-nrow(evidence)\n\tevidence_pgroups<-as.data.frame(do.call(rbind,apply(evidence,1,function(x) cbind(x[\"id\"],unlist(strsplit(x[\"Protein.group.IDs\"],\";\"))))),stringsAsFactors=F)\n\tcolnames(evidence_pgroups)<-c(\"id\",\"Protein.group.IDs\")\n\trow.names(evidence_pgroups)<-NULL\n\tprotein_groups<-protein_groups[protein_groups$id %in% evidence_pgroups$Protein.group.IDs,]\n\tN_proteins_after<-nrow(protein_groups)\n\tcat(paste(\"filter_unlabeled_proteins: Before L peptide filtering (proteins, peptides): \",N_proteins_before,\", \",N_peptides_before,\". After: \",N_proteins_after,\", \",N_peptides_after,\".\\n\",sep=\"\"))\n\treturn(protein_groups)\n}\n\n## PATCHED -- number of conditions/labels-indpendent function\nread.pgroups_v2_PD<-function(fname,evidence_fname,time.point,rep_structure,keepEvidenceIDs=F,rep_order=NA){\n\tlevellog(\"\",change=1)\n\tlevellog(\"Reading data file ...\");\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote=\"\",stringsAsFactors=F,comment.char = \"\")\n\t#Generate Evidence ID\n\tevidence$id<-1:(nrow(evidence))\n\t#Generate Protein IDs\n\tlevellog(\"Generating Protein IDs ...\");\n\tallproteins<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions),length))\n\tallproteins<-data.frame(Protein.IDs=names(allproteins[[1]]),stringsAsFactors=F)\n\t\n\ttmpdf<-evidence[,c(\"Protein.Group.Accessions\",\"Protein.Descriptions\")]\n\tcolnames(tmpdf)<-c(\"Protein.IDs\",\"Protein.Descriptions\")\n\ttmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]\n\tallproteins<-merge(allproteins,tmpdf,by=\"Protein.IDs\",all.x=T)\n\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",allproteins$Protein.IDs)\n\ttmp1<-unlist(lapply(allproteins$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tallproteins$Protein.Group.Accessions<-allproteins$Protein.IDs   #keep old IDs\n  allproteins$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tallproteins$Protein.IDs<-paste(allproteins$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tallproteins<-allproteins[!duplicated(allproteins$Protein.IDs),]\n  \n\tcat(paste(\"read.pgroups_v2_PD: Identified proteins: \",nrow(allproteins),\" (\",time.point,\")\\n\",sep=\"\"))\n\tevidence<-merge(evidence,allproteins,by=\"Protein.Group.Accessions\",all.x=T)\n  levellog(\"Counting number of peptides per protein per label ...\");\n  #Count number of peptides per protein per label\n  subtotals<-ddply(evidence,c(\"Protein.IDs\"),function(x) {\n\t  cond_lengths<-c()\n    conditionscolumn<-\"Modifications\"\n    if(LabelFree){\n      conditionscolumn<-make.names(\"Spectrum File\")\n    }\n\t  heavier.labels.Modifications<-conditions.labels.Modifications\n    light_mod_index<-grep(\"^$\",conditions.labels.Modifications)\n    if(length(light_mod_index) == 1){\n      cond_lengths<-cbind(cond_lengths, length(which(!grepl(unlabeled_peptide_regex,x$Modifications))))\n      heavier.labels.Modifications<-conditions.labels.Modifications[-light_mod_index]\n    }\n\t  for(cond_i in heavier.labels.Modifications){\n\t    labelTruth<-FALSE\n\t    for(label_i in unlist(cond_i)){\n\t      labelTruth<-labelTruth | grepl(label_i,x[,conditionscolumn])\n\t    }\n\t    cond_lengths<-cbind(cond_lengths, length(which(labelTruth)))\n\t  }\n\t  ret<-data.frame(cond_lengths)\n\t  colnames(ret)<-conditions.labels\n\t  return(ret)\n\t})  \n  #Calculate the respective percentages\n  levellog(\"Calculating the respective percentages ...\");\n\tfor(label_i in conditions.labels){\n\t  subtotals$newcol<-apply(subtotals,1,function(x){\n      row_subtotals<-as.numeric(x[-1])\n      if(sum(row_subtotals) == 0){\n        return(0)\n      }else{\n        return(100*(row_subtotals[which(label_i==conditions.labels)]/sum(row_subtotals)))\n      }\n\t    })\n    colnames(subtotals)[length(colnames(subtotals))]<-paste(label_i,\"p\",sep=\"\")\n\t}\n\n  #\n\tevidence$Spectrum.File<-factor(evidence$Spectrum.File)\n  #Remove peptides not suitable for quantitation (those originating from multiple proteins, i.e. not unique)\n  if(length(grep(\"Quan.Info\",colnames(evidence)))>0 & length(grep(\"Quan.Usage\",colnames(evidence)))>0){\n    evidence<-evidence[evidence$Quan.Info==\"Unique\" & evidence$Quan.Usage==\"Used\",]\n  }\n\t\n  \n  #In case of label-free data, add columns of intensities for each condition like with labeled data\n  if(LabelFree){\n    colnames(evidence)[grep(\"Intensity\", colnames(evidence))]<-\"oldIntensity\"\n    new_evidence<-evidence\n    for(cond_i in conditions.labels){\n      new_evidence[,cond_i]<-NA\n    }\n    for(i in 1:length(conditions.labels)){\n      tmpvec<-new_evidence$Spectrum.File %in% paste(unlist(conditions.labels.Modifications[i]),\".raw\",sep=\"\")\n      new_evidence[tmpvec,conditions.labels[i]]<-new_evidence[tmpvec,\"oldIntensity\"]\n    }\n    old_evidence<-evidence\n    evidence<-new_evidence\n  }\n  \n  \n  if(!LabelFree){ \n    levellog(\"Performing peptide-level filtering of single-channel quantitations ...\");\n  \t#Peptide-level filtering of single-channel quantitations (the rest of the channels have the same intensity, i.e. noise level)\n    #There is no point in doing this for label-free data, since they are by definition \"single-channel\" quantitations\n  \tif(ProteinQuantitation && nConditions == 2){ #single-ratio case: implicit (user doesn't have to specify it), so we should protect from noise-level one-to-ones\n  \t  evidence<-evidence[!(evidence[,conditions.labels[1]]==evidence[,conditions.labels[2]]), ]\n  \t}else if(ProteinQuantitation && filterL && filterL_lvl){ #multiple-ratio case: explicit, user have to choose to discard peptides where a certain pair of channels have noise-level intensity\n      labelTruth<-TRUE\n      rest_labels<-conditions.labels[which(conditions.labels != filterL_lbl)]\n      for(lbl_i in rest_labels[-1]){\n        labelTruth<-labelTruth & (evidence[,c(lbl_i)]==evidence[,c(rest_labels[1])])\n      }\n      if(length(rest_labels[-1]) > 0){\n        evidence<-evidence[!labelTruth, ]\n      }\n    }\n  }\n  \n  #====================\n\n  if(ProteinQuantitation){  \n\tlevellog(\"Calculating protein intesity per label and per replicate ...\");\n    #Calculate protein intesity per label and per replicate\n      subtotals2<-ddply(evidence,c(\"Spectrum.File\",\"Protein.IDs\"),function(x){\n        ids<-paste(x$id,collapse=\";\")\n        cond_sums<-c()\n        for(cond_i in conditions.labels){\n          cond_sums<-cbind(cond_sums, sum(x[,cond_i],na.rm=T))\n        }\n        cond_counts<-sum(!is.na(x[,conditions.labels[1]])) # It doesn't matter which label is used for counting. This is the ratio counts, and since PD replaces missing signlas with the minimum intensity, there will always be a ratio, and the number of ratios will be equal to the number of records here. Unwanted ratios, such as those that are equal to 1 and should not be considered/counted are filtered above, at the peptide-filtering stage if chosen by the user (recommended)\n        ret<-data.frame(cbind(cond_sums,cond_counts))\n        colnames(ret)<-c(conditions.labels,\"Ratio.counts\")\n        nUniqueSequences<-length(unique(x$Unique.Sequence.ID))\n        ret$uniqueSequences<-nUniqueSequences\n        ret$Evidence.IDs<-ids\n        return(ret)\n        #data.frame(Evidence.IDs=paste(x$id,collapse=\";\"),Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy)))\n      })    \n  }else{\n    #Calculate peptide intesity per label and per replicate\n\tlevellog(\"Calculating peptide intesity per label and per replicate ...\");\n    #First, We have to remove the labels from the modifications column, because we have to pivot on modifications but not on labels\n    modcol<-evidence$Modifications\n    for(i in 1:length(conditions.labels)){\n      for(mod_i in conditions.labels.Modifications[[i]]){\n        if(mod_i != \"\"){\n          modcol<-gsub(paste(\"[A-Z]+[0-9]+\\\\(\",mod_i,\"[; ]*\",sep=\"\"),\"\",modcol)\n        }\n      }\n    }\n    modcol<-gsub(\"^[ ]+\",\"\",modcol)\n    modcol<-gsub(\";[ ]+$\",\"\",modcol)\n    evidence[,\"Modifications.only\"]<-modcol\n\n    subtotals2<-ddply(evidence,c(\"Spectrum.File\",\"Unique.Sequence.ID\",\"Modifications.only\"),function(x){\n      cond_sums<-c()\n      for(cond_i in conditions.labels){\n        cond_sums<-cbind(cond_sums, sum(x[,cond_i],na.rm=T))\n      }\n      cond_counts<-sum(!is.na(x[,conditions.labels[1]])) # It doesn't matter which label is used for counting. This is the ratio counts, and since PD replaces missing signlas with the minimum intensity, there will always be a ratio, and the number of ratios will be equal to the number of records here. Unwanted ratios, such as those that are equal to 1 and should not be considered/counted are filtered above, at the peptide-filtering stage if chosen by the user (recommended)\n      ret<-data.frame(cbind(cond_sums,cond_counts))\n      colnames(ret)<-c(conditions.labels,\"Ratio.counts\")\n      ret$Evidence.IDs<-paste(x$id,collapse=\";\")\n      ret$Sequence<-toupper(x$Sequence[1])\n      ret$Protein.IDs<-x$Protein.IDs[1]\n      return(ret)    \n      #data.frame(Evidence.IDs=paste(x$id,collapse=\";\"),Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy)))\n    })    \n  }\n  \n\t#write.table(file=\"tmp.txt\",subtotals2,row.names=F,sep=\"\\t\")\n\n\tlevellog(\"Re-arranging data and assigning column names ...\");\n  #Re-arrange data and assign column names\n\tif(ProteinQuantitation){\n    melted_subtotals<-melt(subtotals2)\n\t}else{\n\t  melted_subtotals<-melt(subtotals2,id.vars=c(\"Spectrum.File\", \"Modifications.only\", \"Evidence.IDs\", \"Sequence\", \"Protein.IDs\", \"Unique.Sequence.ID\"))\n\t}\n\n\tn_bioreps<-length(which(!duplicated(rep_structure)))/nConditions\n\tn_techreps<-length(rep_structure)/(n_bioreps*nConditions)\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]\n\t\n\t\n  melted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n\n\trep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/nConditions)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\tif(!is.na(rep_order)){\n\t\to<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n\t\trep_desc<-rep_desc[o]\n\t}\n\t# For the label-free case: multiplex conditions so we have the same data format downstream, i.e. as with labelled experiments\n  if(LabelFree){\n    tmp_rep_desc<-c()\n    for(i in 1:nConditions){\n      tmp_rep_desc[[i]]<-paste(\"c\",i,rep_desc,sep=\"\")\n      levels(melted_subtotals$Spectrum.File)[which(levels(melted_subtotals$Spectrum.File) %in% paste(conditions.labels.Modifications[[i]],\".raw\",sep=\"\"))]<-tmp_rep_desc[[i]]\n    }\n    rep_desc<-unlist(tmp_rep_desc)\n    melted_subtotals$brtr<-NA\n    biorep_techrep<-regmatches(levels(melted_subtotals$Spectrum.File), regexpr(\"b.*\", levels(melted_subtotals$Spectrum.File)))\n    for(i in 1:length(levels(melted_subtotals$Spectrum.File))){\n      lvl_i<-levels(melted_subtotals$Spectrum.File)[i]\n      brtr<-biorep_techrep[i]\n      melted_subtotals[melted_subtotals$Spectrum.File == lvl_i,\"brtr\"]<-brtr\n    }\n    melted_subtotals$brtr<-factor(melted_subtotals$brtr)\n  }else{\n    levels(melted_subtotals$Spectrum.File)<-rep_desc\n  }\n\n\tif(ProteinQuantitation){\n    if(LabelFree){\n      pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$brtr,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n    }else{\n      pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n    }\n\t}else{\n\t  pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Peptide.IDs=paste(melted_subtotals$Sequence,\" [\",melted_subtotals$Modifications.only,\"]\",sep=\"\"),RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n\t}\n\n\tfor(cond_i in conditions.labels){\n\t  colnames(pgroups)[grep(paste(\"\\\\.\",cond_i,\"$\",sep=\"\"),colnames(pgroups))]<-sub(paste(\"(.*)\\\\.\",cond_i,sep=\"\"),paste(\"Intensity.\",cond_i,\".\\\\1\",sep=\"\"),colnames(pgroups)[grep(paste(\"\\\\.\",cond_i,\"$\",sep=\"\"),colnames(pgroups))])\n\t}  \n  \n\tpgroups[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]<-row.names(pgroups)\n\n\t#Collect peptide records for each protein \n\tif(keepEvidenceIDs && ProteinQuantitation)\n\t{\n\t  all_evidence_ids<-ddply(subtotals2,c(\"Protein.IDs\"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=\";\")))\n\t\tpgroups<-merge(pgroups,all_evidence_ids,by=paste(quantitated_items_lbl,\".IDs\",sep=\"\"),all.x=T)\n\t}\n\n  if(ProteinQuantitation){\n\t  pgroups<-pgroups[,!(colnames(pgroups) %in% c(\"Protein.Descriptions\"))]\n  }\n\tpgroups$time.point<-time.point\n\tif(!ProteinQuantitation){\n\t  subtotals2$Peptide.IDs<-paste(subtotals2$Sequence,\" [\",subtotals2$Modifications.only,\"]\",sep=\"\")\n\t  pgroups<-merge(pgroups,subtotals2[!duplicated(subtotals2$Peptide.IDs),c(\"Peptide.IDs\",\"Protein.IDs\")],by=\"Peptide.IDs\",all.x=T)\n\t  # Remove peptides that we don't want to quantify (conditions.Mod is not empty means the user wants to do quantification on peptides with certain modifications only)\n    if(length(conditions.Mods)>0){\n      for(i in 1:length(conditions.Mods)){\n        for(mod_i_mods in conditions.Mods.Modifications[[i]]){\n          pgroups<-pgroups[grepl(mod_i_mods,pgroups$Peptide.IDs),]\n        }\n\t    }\n\t  }\n    #write.table(file=\"tmp.txt\",merge(pgroups,subtotals2[!duplicated(subtotals2$Peptide.IDs),c(\"Peptide.IDs\",\"Protein.IDs\")],by=\"Peptide.IDs\",all.x=T),row.names=F,sep=\"\\t\")\n\t}\n  pgroups<-merge(pgroups,subtotals,by=\"Protein.IDs\",all.x=T)\n\n  #If enabled, do filter out proteins based on percentage labeling for the desired label\n  if(ProteinQuantitation && filterL && !filterL_lvl){\n\tlevellog(\"Filter out proteins based on percentage labeling for the desited label ...\");\n    fl<-paste(filterL_lbl,\"p\",sep=\"\")\n    pgroups<-pgroups[pgroups[,c(fl)]<100,]\n  }\n  \n  if(ProteinQuantitation){\n\t  cat(paste(\"read.pgroups_v2_PD: Quantifiable proteins: \",nrow(pgroups),\" (\",time.point,\")\\n\",sep=\"\"))\n  }else{\n    cat(paste(\"read.pgroups_v2_PD: Quantifiable peptides: \",nrow(pgroups),\" (\",time.point,\")\\n\",sep=\"\"))\n  }\n\t\n\trow.names(pgroups)<-pgroups[,paste(quantitated_items_lbl,\".IDs\",sep=\"\")]\n\t\n\tlevellog(\"\",change=-1)\n\treturn(pgroups)\n}\n\n# VALIDATION HELP\n# For MaxQuant only, for PD this can be done much better through its GUI\ngetValidationData<-function(pgroups_fname,diffexp_fname,evidence_fname,output_fname){\n\tdiffexp<-read.table(diffexp_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\tprotein_groups<-read.table(pgroups_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t\n\tcolnames(diffexp)<-gsub(\"^X.\",\"\",colnames(diffexp))\n\tcolnames(diffexp)<-gsub(\".$\",\"\",colnames(diffexp))\n\n\tprotein_groups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.IDs),\" ...]\",sep=\"\")\n\tprotein_groups$Protein.IDs<-gsub(\"\\\"\",\"\",protein_groups$Protein.IDs)\n\tdiffexp$Protein.IDs<-gsub(\"\\\"\",\"\",diffexp$Protein.IDs)\n\tprotein_groups<-protein_groups[protein_groups$Protein.IDs %in% diffexp$Protein.IDs,]\n\tdiffexp_evidence<-as.data.frame(do.call(rbind,apply(protein_groups,1,function(x) cbind(x[\"Protein.IDs\"],unlist(strsplit(x[\"Evidence.IDs\"],\";\"))))),stringsAsFactors=F)\n\tcolnames(diffexp_evidence)<-c(\"Protein.IDs\",\"Evidence.ID\")\n\tdiffexp_evidence$Protein.IDs<-factor(diffexp_evidence$Protein.IDs)\n\tdiffexp_evidence$Evidence.ID<-as.numeric(diffexp_evidence$Evidence.ID)\n\tevidence<-evidence[,c(\"id\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error..ppm.\",\"K.Count\",\"R.Count\")]\n\tcolnames(evidence)<-c(\"Evidence.ID\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error.ppm.\",\"K.Count\",\"R.Count\")\n\tdiffexp_evidence<-merge(diffexp_evidence,diffexp,by=\"Protein.IDs\",all.x=T)\n\tdiffexp_evidence<-merge(diffexp_evidence,evidence,by=\"Evidence.ID\",all.x=T)\n\twrite.table(diffexp_evidence,file=output_fname,sep=\"\\t\",row.names=F)\n}\n\n#getValidationData(pgroups_fname=\"QuaNCATrev_IV_4h_proteinGroups.txt\",\n#diffexp_fname=\"QuaNCAT-rev_IV_4h_HM-all-2reps_diffexp_4h.txt\",\n#evidence_fname=\"QuaNCATrev_IV_4h_evidence.txt\",\n#output_fname=\"QuaNCATrev_IV_4h_HM-all-2reps_diffexpevidence.txt\")\n\n# Again, for MaxQuant only\ngetProteinPeptideData_2reps_filter<-function(pgroups_fname,evidence_fname,output_fname,time.point, filterL=T,linkLimmaout=F,limma_outfname=\"\"){\n\tprotein_groups<-read.pgroups_v2(pgroups_fname,time.point,filterL=filterL,evidence_fname=evidence_fname,keepEvidenceIDs=T)\n\tprotein_groups<-pgroups_filter_2reps_v2(protein_groups[protein_groups$time.point == time.point,])\n\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t\n\tpeptide_evidence<-as.data.frame(do.call(rbind,apply(protein_groups,1,function(x) cbind(x[\"Protein.IDs\"],unlist(strsplit(x[\"Evidence.IDs\"],\";\"))))),stringsAsFactors=F)\n\tcolnames(peptide_evidence)<-c(\"Protein.IDs\",\"Evidence.ID\")\n\tpeptide_evidence$Protein.IDs<-factor(peptide_evidence$Protein.IDs)\n\tpeptide_evidence$Evidence.ID<-as.numeric(peptide_evidence$Evidence.ID)\n\tevidence<-evidence[,c(\"id\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error..ppm.\",\"K.Count\",\"R.Count\",\"Protein.group.IDs\")]\n\tcolnames(evidence)<-c(\"Evidence.ID\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error.ppm.\",\"K.Count\",\"R.Count\",\"Protein.group.IDs\")\n\tpeptide_evidence<-merge(peptide_evidence,protein_groups[,!names(protein_groups) %in% c(\"Evidence.IDs\")],by=\"Protein.IDs\",all.x=T)\n\tpeptide_evidence<-merge(peptide_evidence,evidence,by=\"Evidence.ID\",all.x=T)\n\tif(linkLimmaout){\n\t\tlimmaout<-read.table(limma_outfname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t\tpeptide_evidence<-merge(peptide_evidence,limmaout,by=\"Protein.IDs\",all.x=T)\n\t}\n\twrite.table(peptide_evidence,file=output_fname,sep=\"\\t\",row.names=F)\n}\n\n#getProteinPeptideData_2reps_filter(\n#\"QuaNCATrev_IV_2h_proteinGroups.txt\",\n#\"QuaNCATrev_IV_2h_evidence.txt\",\n#\"QuaNCATrev_IV_2h_HM-all-2reps_evidence.txt\",\n#\"2h\",\n#filterL=T,\n#linkLimmaout=T,\n#limma_outfname=\"QuaNCAT-rev_IV_2h_HM-all-2reps_limmaout_2h.txt\")\n\n#GLOBAL variables\n\nduplicateCorrelation_trim<-0.15 # use 0.22 for \"bad\" datasets (too many missing values)\n\n\n#\nparamssetfromGUI<-F\ngetParamsViaGUI <- function(){\n\tbase <<- tktoplevel()\n\t#tkwm.deiconify(base)\n\t#tkgrab.set(base)\n\t#tkfocus(base)\n\ttkwm.title(base,'MS-based proteomics data differential expression analysis')\n\tparamstkframe <- tkframe(base)\n\n\t# create tcl variables to associate with the \n\t# entry fields -- to include starting values\n\t# replace the '' with the desired value\n\ttime.point_ <- tclVar('')\n\tPDdata_ <- tclVar('0')\n\toutputFigsPrefix_ <- tclVar('')\n\tfilterL_ <- tclVar('0')\n\tfilterL_lvl_ <- tclVar('1')\n\tfilterL_lbl_ <- tclVar(conditions.labels[1])\n\tpgroups_fname_ <- tclVar('')\n\tevidence_fname_ <- tclVar('')\n\tmqValidation_ <- tclVar('0')\n\trep_order_ <- tclVar('')\n  techreps_ <- tclVar('3')\n\tbioreps_ <- tclVar('3')\n\tProteinQuantitation_ <- tclVar('1')\n\n\ttkLabelWidth<-40\n\ttkLabelWidthFac<-0.85\n\ttkLabelWidth2<-as.integer(tkLabelWidth*tkLabelWidthFac)\n\tpgroupsentry<-tklabel(paramstkframe,anchor='w', width=tkLabelWidth,text='',relief='ridge')\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Protein file',width=tkLabelWidth2),row=0,column=0)\n\ttkgrid(pgroupsentry,row=0,column=1)\n\t\n\tevidenceentry<-tklabel(paramstkframe,anchor='w', width=tkLabelWidth,text='',relief='ridge')\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Peptide file',width=tkLabelWidth2),row=1,column=0)\n\ttkgrid(evidenceentry,row=1,column=1)  \n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Proteome Discoverer quantitation ?',width=tkLabelWidth2),row=2,column=0)\n  tkgrid(tkcheckbutton(paramstkframe,variable=PDdata_,command=function(...){\n    if(as.numeric(tclvalue(PDdata_))==1){\n      tkconfigure(validationlabel, state=\"disabled\");\n      tkconfigure(validationcheck, state=\"disabled\");\n      tkconfigure(bioorderlabel, state=\"normal\");\n      tkconfigure(bioorderentry, state=\"normal\");\n      tkconfigure(techrepslabel, state=\"normal\");\n      tkconfigure(techrepsentry, state=\"normal\");\n      tkconfigure(biorepslabel, state=\"normal\");\n      tkconfigure(biorepsentry, state=\"normal\");   \n    }else{\n      tkconfigure(validationlabel, state=\"normal\");\n      tkconfigure(validationcheck, state=\"normal\");      \n      tkconfigure(bioorderlabel, state=\"disabled\");\n      tkconfigure(bioorderentry, state=\"disabled\");      \n      tkconfigure(techrepslabel, state=\"disabled\");\n      tkconfigure(techrepsentry, state=\"disabled\");\n      tkconfigure(biorepslabel, state=\"disabled\");\n      tkconfigure(biorepsentry, state=\"disabled\");   \n    }\n\t}),row=2,column=1)\n\t\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Timepoint [text]',width=tkLabelWidth2),row=3,column=0)\n\ttkgrid(tkentry(paramstkframe,width=tkLabelWidth,textvariable=time.point_),row=3,column=1)\n\t\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Output figure file prefix [text]',width=tkLabelWidth2),row=4,column=0)\n  tkgrid(tkentry(paramstkframe,width=tkLabelWidth,textvariable=outputFigsPrefix_),row=4,column=1)\n\t\n  dslbqlbl<-tklabel(paramstkframe,anchor='w', text='Disregard single-label-based quantitation ?',width=tkLabelWidth2)\n  tkgrid(dslbqlbl,row=5,column=0)\n\tdslbchk<-tkcheckbutton(paramstkframe,width=tkLabelWidth,variable=filterL_,command=function(...){\n\t  st<-\"disabled\"\n    if(as.numeric(tclvalue(filterL_))==1){\n      st<-\"normal\"\n\t  }\n    handles<-c(filterL_rb, filterL_rb_lbl, filterL_lvl_rb, filterL_lvl_rb_lbl)\n\t  for(h in handles){\n\t    tkconfigure(h, state=st)  \n\t  }\n\t})\n\ttkgrid(dslbchk,row=5,column=1)\n\tif(nConditions < 3){\n\t  tkconfigure(dslbqlbl, state=\"disabled\");\n\t  tkconfigure(dslbchk, state=\"disabled\");\n\t}\n  \n  filterL_lvl_rb<<-list()\n\tfilterL_lvl_rb_lbl<<-list()\n  \n\trb<-tkradiobutton(paramstkframe)\n\ttkconfigure(rb,variable=filterL_lvl_,value=0,state=\"disabled\")\n\trb_lbl<-tklabel(paramstkframe,text=\"Sequence-based\",state=\"disabled\")\n\ttkgrid(rb_lbl,row=6,column=1)\n\ttkgrid(rb,row=6,column=2)\n\tfilterL_lvl_rb[[length(filterL_lvl_rb)+1]]<<-rb\n\tfilterL_lvl_rb_lbl[[length(filterL_lvl_rb_lbl)+1]]<<-rb_lbl\n  \n\trb<-tkradiobutton(paramstkframe)\n\ttkconfigure(rb,variable=filterL_lvl_,value=1,state=\"disabled\")\n\trb_lbl<-tklabel(paramstkframe,text=\"Intensity-based\",state=\"disabled\")\n\ttkgrid(rb_lbl,row=7,column=1)\n\ttkgrid(rb,row=7,column=2)\n\tfilterL_lvl_rb[[length(filterL_lvl_rb)+1]]<<-rb\n\tfilterL_lvl_rb_lbl[[length(filterL_lvl_rb_lbl)+1]]<<-rb_lbl  \n  \n  tmp_row<-8\n  filterL_rb<<-list()\n\tfilterL_rb_lbl<<-list()\n  for(cond_i in conditions.labels){\n    rb<-tkradiobutton(paramstkframe)\n    tkconfigure(rb,variable=filterL_lbl_,value=cond_i,state=\"disabled\")\n    rb_lbl<-tklabel(paramstkframe,text=cond_i,state=\"disabled\")\n    tkgrid(rb_lbl,row=tmp_row,column=1)\n    tkgrid(rb,row=tmp_row,column=2)\n    filterL_rb[[length(filterL_rb)+1]]<<-rb\n    filterL_rb_lbl[[length(filterL_rb_lbl)+1]]<<-rb_lbl\n    tmp_row<-tmp_row+1\n  }\n\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Timepoint [text]',width=tkLabelWidth2),row=tmp_row,column=0)\n\ttkgrid(tkentry(paramstkframe,width=tkLabelWidth,textvariable=time.point_),row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Output figure file prefix [text]',width=tkLabelWidth2),row=tmp_row,column=0)\n\ttkgrid(tkentry(paramstkframe,width=tkLabelWidth,textvariable=outputFigsPrefix_),row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n  validationlabel<<-tklabel(paramstkframe,anchor='w', text='Generate validation data ? (MQ)',width=tkLabelWidth2)\n  validationcheck<<-tkcheckbutton(paramstkframe,width=tkLabelWidth,variable=mqValidation_)\n\ttkgrid(validationlabel,row=tmp_row,column=0)\n  tkgrid(validationcheck,row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n\tbiorepslabel<<-tklabel(paramstkframe,anchor='w', text='Samples (replicates) [number]',width=tkLabelWidth2,state='disabled')\n\tbiorepsentry<<-tkentry(paramstkframe,width=tkLabelWidth,textvariable=bioreps_,state='disabled')\n\ttkgrid(biorepslabel,row=tmp_row,column=0)\n\ttkgrid(biorepsentry,row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n\tbioorderlabel<<-tklabel(paramstkframe,anchor='w', text='Acquisition order [space-separated numbers]',width=tkLabelWidth2,state='disabled')\n\tbioorderentry<<-tkentry(paramstkframe,width=tkLabelWidth,textvariable=rep_order_,state='disabled')\n\ttkgrid(bioorderlabel,row=tmp_row,column=0)\n\ttkgrid(bioorderentry,row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n  techrepslabel<<-tklabel(paramstkframe,anchor='w', text='LC-MS/MS runs per sample [number]',width=tkLabelWidth2,state='disabled')\n\ttechrepsentry<<-tkentry(paramstkframe,width=tkLabelWidth,textvariable=techreps_,state='disabled')\n\ttkgrid(techrepslabel,row=tmp_row,column=0)\n  tkgrid(techrepsentry,row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n\ttkgrid(tklabel(paramstkframe,anchor='w', text='Protein quantitation ?',width=tkLabelWidth2),row=tmp_row,column=0)\n\ttkgrid(tkcheckbutton(paramstkframe,variable=ProteinQuantitation_),row=tmp_row,column=1)\n\ttmp_row<-tmp_row+1\n  \n\ttkbind(pgroupsentry,'<Button-1>',function(...){\n\t\tchosenfile<-tk_choose.files(multi=F, caption = \"Select protein file\", filter=matrix(c(\"Text\", \".txt\"), 1, 2, byrow = TRUE));\n\t\tif(length(chosenfile)>0){\n\t\t\tworking_directory<<-dirname(chosenfile);\n\t\t\tsetwd(working_directory);\n\t\t\tchosenfile<-basename(chosenfile);\n\t\t\ttkconfigure(pgroupsentry,text=chosenfile);\n\t\t\ttclvalue(pgroups_fname_)<-chosenfile;\n\t\t\ttkraise(base);   \n\t\t\t}\n\t})\n\ttkbind(evidenceentry,'<Button-1>',function(...){\n\t\tchosenfile<-tk_choose.files(multi=F, caption = \"Select peptide file\", filter=matrix(c(\"Text\", \".txt\"), 1, 2, byrow = TRUE));\n\t\tif(length(chosenfile)>0){\n\t\t\tworking_directory<<-dirname(chosenfile);\n\t\t\tsetwd(working_directory);\n\t\t\tchosenfile<-basename(chosenfile);\n\t\t\ttkconfigure(evidenceentry,text=chosenfile);\n\t\t\ttclvalue(evidence_fname_)<-chosenfile;\n\t\t\ttkraise(base);\n\t\t}\n\t})\n\n\ttkpack(paramstkframe,side='top', pady=c(10,10))\n\tcontrolbtnstkframe = tkframe(base)\n\ttkgrid(tkbutton(controlbtnstkframe,text='Apply & Run',command=function(...){\n\t\ttime.point <<- tclvalue(time.point_);\n\t\tPDdata <<- as.numeric(tclvalue(PDdata_))==1;\n\t\tProteinQuantitation <<- as.numeric(tclvalue(ProteinQuantitation_))==1;\n    if(ProteinQuantitation){\n      quantitated_items_lbl<<-\"Protein\"\n    }else{\n      quantitated_items_lbl<<-\"Peptide\"\n    }\n\t\toutputFigsPrefix <<- tclvalue(outputFigsPrefix_);\n\t\tfilterL <<- as.numeric(tclvalue(filterL_))==1;\n\t\tfilterL_lvl <<- as.numeric(tclvalue(filterL_lvl_))==1;\n\t\tfilterL_lbl <<- as.character(tclvalue(filterL_lbl_));\n\t\tpgroups_fname <<- tclvalue(pgroups_fname_);\n\t\tevidence_fname <<- tclvalue(evidence_fname_);\n\t\tmqValidation <<- as.numeric(tclvalue(mqValidation_))==1;\n\t\trep_order <<- as.numeric(unlist(strsplit(tclvalue(rep_order_),\" \")));\n\t\ttechreps <<- as.numeric(unlist(strsplit(tclvalue(techreps_),\" \")));\n\t\tbioreps <<- as.numeric(unlist(strsplit(tclvalue(bioreps_),\" \")));\n\t\tif(length(rep_order) == 0){\n\t\t  rep_order<<-NA\n\t\t}\n\t\tif(length(techreps_) == 0){\n\t\t  techreps<<-3\n\t\t}\n\t\tif(length(bioreps_) == 0){\n\t\t  bioreps<<-3\n\t\t}\n\t\tparamssetfromGUI <<- T;\n\t\ttkgrab.release(base); tkdestroy(base)\n\t}),tkbutton(controlbtnstkframe,text='Cancel',command=function(...){ \n\t\ttkgrab.release(base); tkdestroy(base)\n\t}))\t\n\ttkpack(controlbtnstkframe,side='bottom', pady=c(10,10))\n\n  #handles<<-c(validationlabel, validationcheck, bioorderlabel, bioorderentry, techrepslabel, techrepsentry, biorepslabel, biorepsentry, filterL_rb, filterL_rb_lbl, filterL_lvl_rb, filterL_lvl_rb_lbl) \n  #for(h in handles){\n  #  print(h)\n  #  tkconfigure(h, state=\"disabled\")\n  #}\n\t#tkraise(base)\n\ttkwait.window(base)\n}\n\naddLabel<-function(lblname, lbl.Modifications){\n  #If label name is a number some routines won't work, it has to be converted to some acceptable variable name\n  lblname<-make.names(lblname)\n  labeltxt <- \"label\";\n  if(!LabelFree){\n    lbl.Modifications<-gsub(\"\\\\(\",\"\\\\\\\\(\",lbl.Modifications)\n    lbl.Modifications<-gsub(\"\\\\)\",\"\\\\\\\\)\",lbl.Modifications)\n    unmod_idx<-which(lbl.Modifications == \"\")\n    if(length(unmod_idx) > 0){\n      rest_idx<-which(lbl.Modifications[-unmod_idx] != \"\")\n      if(length(rest_idx) > 0){\n        lbl.Modifications<-c(lbl.Modifications[unmod_idx],paste(lbl.Modifications[-unmod_idx],\"\\\\)\",sep=\"\"))\n        lbl.Modifications<-c(lbl.Modifications[unmod_idx],paste(\"Label:\",lbl.Modifications[-unmod_idx],sep=\"\"))    \n      }\n    }else{\n      lbl.Modifications<-paste(lbl.Modifications,\"\\\\)\",sep=\"\")\n      lbl.Modifications<-paste(\"Label:\",lbl.Modifications,sep=\"\")  \n    }\n  }else{\n    labeltxt <- \"condition\";\n  }\n  lblname_i<-which(grepl(paste(\"^\",lblname,\"$\",sep=\"\"),conditions.labels))\n  if(length(lblname_i) != 0){\n    cat(paste(\"addLabel: Error adding \",labeltxt,\" '\",lblname,\"': An existing \",labeltxt,\" with name '\",lblname,\"' (specification: \",paste(unlist(conditions.labels.Modifications[lblname_i]),collapse=\", \"),\") already exists. Please try a different name.\",sep=\"\"))\n    return(FALSE)\n  }\n\n#   i<-1\n#   for(lbl_i in conditions.labels.Modifications){\n#     for(mod_i in lbl.Modifications){\n#       lbl_i_matches<-which(grepl(paste(\"^\",mod_i,\"$\",sep=\"\"),lbl_i))\n#       if(length(lbl_i_matches) != 0){\n#         cat(paste(\"addLabel: Error adding label '\",lblname,\"': Existing label with name '\",conditions.labels[i],\"' has an identical modification (\",mod_i,\").\",sep=\"\"))\n#         return(FALSE)\n#       }\n#     }\n#     i<-i+1\n#   }\n  \n  conditions.labels<<-c(conditions.labels, lblname)\n  j<-length(conditions.labels.Modifications)+1\n  conditions.labels.Modifications[[j]]<<-lbl.Modifications\n  nConditions<<-length(conditions.labels)\n}\nremoveLabel<-function(lblname){\n  lblname_i<-which(grepl(paste(\"^\",lblname,\"$\",sep=\"\"),conditions.labels))\n  if(length(lblname_i) != 0){\n    conditions.labels<<-conditions.labels[-lblname_i]\n    conditions.labels.Modifications<<-conditions.labels.Modifications[-lblname_i]\n  }\n  nConditions<<-length(conditions.labels)\n}\nclearLabels<-function(){\n  conditions.labels<<-c()\n  conditions.labels.Modifications<<-list()\n  nConditions<<-length(conditions.labels)\n}\n\naddMod<-function(modname, mod.Modifications){\n  modname<-make.names(modname)\n  mod.Modifications<-gsub(\"\\\\(\",\"\\\\\\\\(\",mod.Modifications)\n  mod.Modifications<-gsub(\"\\\\)\",\"\\\\\\\\)\",mod.Modifications)\n  unmod_idx<-which(mod.Modifications == \"\")\n  if(length(unmod_idx) > 0){\n    rest_idx<-which(mod.Modifications[-unmod_idx] != \"\")\n    if(length(rest_idx) > 0){\n      mod.Modifications<-c(mod.Modifications[unmod_idx],paste(mod.Modifications[-unmod_idx],\"\\\\)\",sep=\"\"))\n    }\n  }else{\n    mod.Modifications<-paste(mod.Modifications,\"\\\\)\",sep=\"\")\n  }\n  modname_i<-which(grepl(paste(\"^\",modname,\"$\",sep=\"\"),conditions.Mods))\n  if(length(modname_i) != 0){\n    cat(paste(\"addMod: Error adding modification '\",modname,\"': An existing modification with name '\",modname,\"' (specification: \",paste(unlist(conditions.Mods.Modifications[modname_i]),collapse=\", \"),\") already exists. Please try a different name.\",sep=\"\"))\n    return(FALSE)\n  }\n  i<-1\n  for(mod_i in conditions.Mods.Modifications){\n    for(mod_i in mod.Modifications){\n      mod_i_matches<-which(grepl(paste(\"^\",mod_i,\"$\",sep=\"\"),mod_i))\n      if(length(mod_i_matches) != 0){\n        cat(paste(\"addMod: Error adding modification '\",modname,\"': Existing modification with name '\",conditions.Mods[i],\"' has an identical specification (\",mod_i,\").\",sep=\"\"))\n        return(FALSE)\n      }\n    }\n    i<-i+1\n  }\n  conditions.Mods<<-c(conditions.Mods, modname)\n  j<-length(conditions.Mods.Modifications)+1\n  conditions.Mods.Modifications[[j]]<<-mod.Modifications\n  nMods<<-length(conditions.Mods)\n}\nremoveMod<-function(modname){\n  modname_i<-which(grepl(paste(\"^\",modname,\"$\",sep=\"\"),conditions.Mods))\n  if(length(modname_i) != 0){\n    conditions.Mods<<-conditions.Mods[-modname_i]\n    conditions.Mods.Modifications<<-conditions.Mods.Modifications[-modname_i]\n  }\n  nMods<<-length(conditions.Mods)\n}\nclearMods<-function(){\n  conditions.Mods<<-c()\n  conditions.Mods.Modifications<<-list()\n  nMods<<-length(conditions.Mods)\n}\n\nunlabeled_peptide_regex<-\"^Label:$\"\nclearLabels()\nclearMods()\nparamssetfromGUI<-F\nworking_directory<-getwd()\nlimma_output<-\"msdiffexp_out\"\nLabelFree<-F\nsource(\"MSdiffexp_definitions.R\")\n\nif(GUI){\n\tgetParamsViaGUI()\n}\n\nperform_analysis<-function(){\n  levellog(\"\",change=1)\n  setwd(working_directory)\n  rep_structure<<-rep(1:(bioreps*nConditions),each=techreps)\n  if(ProteinQuantitation){\n    quantitated_items_lbl<<-\"Protein\"\n  }else{\n    quantitated_items_lbl<<-\"Peptide\"\n  }\n  if(!file.exists(limma_output)){dir.create(limma_output)}\n  levellog(\"Removing double quotes from input data ...\")\n  tmpdata<-gsub(\"\\\"\", \"\", readLines(evidence_fname))\n  evidence_fname_cleaned<-file(evidence_fname, open=\"w\")\n  writeLines(tmpdata, con=evidence_fname_cleaned)\n  close(evidence_fname_cleaned)\n  tmpdata<-gsub(\"\\\"\", \"\", readLines(pgroups_fname))\n  pgroups_fname_cleaned<-file(pgroups_fname, open=\"w\")\n  writeLines(tmpdata, con=pgroups_fname_cleaned)\n  close(pgroups_fname_cleaned)\n  levellog(\"Reading input data ...\")\n  if(PDdata){\n    #If label definitions are the same, it will be interpreted that the information is not stored in the \"modifications\" column of the PD PSMs file, which occurs when the labelling is at the MS/MS level.\n    #Thus, if the above condition is true, we have multiplexion at the MS/MS level (e.g. iTRAQ, TMTs etc) and the \"Label:\" part of the regular expression has to be removed from the labels definitions\n    if(length(which(conditions.labels.Modifications[[1]]==conditions.labels.Modifications)) == length(conditions.labels.Modifications)){\n      conditions.labels.Modifications<-lapply(conditions.labels.Modifications, function(x){sub(\"Label:\",\"\",x)})\n    }  \n    protein_groups<<-read.pgroups_v2_PD(pgroups_fname,evidence_fname,time.point,rep_structure,keepEvidenceIDs=T,rep_order=rep_order)\n    do_generate_Venn3_data_quant_filter_2reps_PD(protein_groups,time.point,evidence_fname,rep_structure,outputFigsPrefix=outputFigsPrefix,rep_order=rep_order)\n  }else{\n    protein_groups<<-read.pgroups_v2(pgroups_fname,evidence_fname,time.point)\n    do_generate_Venn3_data_quant_filter_2reps(protein_groups,time.point,outputFigsPrefix=outputFigsPrefix)\n  }\n  #setwd(limma_output)\n  #write.table(protein_groups,file=paste(outputFigsPrefix,\"_features.txt\",sep=\"\"),row.names=F,sep=\"\\t\")\n  #setwd(\"..\")\n  \n  expdesign<-c()\n  for(cond_i in conditions.labels){\n    expdesign<-rbind(expdesign,cbind(paste(sub(\"Intensity\\\\.\",\"\",sort(colnames(protein_groups)[grep(paste(\"Intensity.\",cond_i,\".b\",sep=\"\"),colnames(protein_groups))]))),cond_i))  \n  }\n  colnames(expdesign)<-c(\"Sample\",\"Category\")\n  write.table(expdesign,file=\"curr_exp_design.txt\",row.names=F,quote=F,sep = \"\\t\")\n  exp_design_fname<<-\"curr_exp_design.txt\"\n  \n  levellog(\"Performing the analysis ...\")\n  results<-do_analyse_all_2reps_v2(protein_groups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=outputFigsPrefix)\n  levellog(\"Data analysis finished.\")\n  if(!PDdata & mqValidation){\n    getValidationData(pgroups_fname=pgroups_fname,\n                      diffexp_fname=paste(outputFigsPrefix,\"-all-2reps_diffexp_\",time.point,\".txt\",sep=\"\"),\n                      evidence_fname=evidence_fname,\n                      output_fname=paste(outputFigsPrefix,\"-all-2reps_diffexpevidence_\",time.point,\".txt\",sep=\"\"))\n    \n    getProteinPeptideData_2reps_filter(\n      pgroups_fname,\n      evidence_fname,\n      paste(outputFigsPrefix,\"-all-2reps_evidence.txt\",sep=\"\"),\n      time.point,\n      filterL=filterL,\n      linkLimmaout=T,\n      limma_outfname=paste(outputFigsPrefix,\"-all-2reps_limmaout_\",time.point,\".txt\",sep=\"\"))\t\t\t\n  }\n  levellog(\"\",change=-1)\n}\n\n#================ PRODUCTION ===============\n\nif(GUI & !paramssetfromGUI){\n  \n}else{\n  perform_analysis()\n}\n\n\n#================ TESTING ===============\n# nParams<-4\n# nCombs<-2^nParams\n# combs_to_test<-(nCombs-1):0\n# combs_to_test<-combs_to_test[1]\n# for(ci in combs_to_test){\n#   #Binary representation of ci reveals the parameter combination, because each param is a binary variable\n#   #Assumes that integer is a 32-bit variable (it doesn't have to do with machine architecture, apparently)\n#   paramset<-as.numeric(unlist(strsplit(substring(paste(rev(as.integer(intToBits(ci))), collapse=\"\"),32-nParams+1),\"\")))\n#   PDdata<-paramset[1]\n#   ProteinQuantitation<-paramset[2]\n#   filterL<-paramset[3]\n#   filterL_lvl<-paramset[4]\n#   \n#   if(PDdata){\n#     pgroups_fname <- \"PD_psms.txt\"\n#     evidence_fname <- pgroups_fname\n#   }else{\n#     pgroups_fname <- \"MQ_proteingroups.txt\"\n#     evidence_fname <- \"MQ_evidence.txt\"\n#     fname<-pgroups_fname  \n#   }  \n#   cat(paste(\"Executing with paramset #\",(ci+1),\" {PDdata, ProteinQuantitation, filterL, filterL_lvl}={\",PDdata,\",\", ProteinQuantitation,\",\", filterL,\",\", filterL_lvl, \"} ...\\n\",sep=\"\"))\n#   #cat(paste(\"Execute with paramset #\",(ci+1),\" {PDdata, ProteinQuantitation, filterL, filterL_lvl}={\",PDdata,\",\", ProteinQuantitation,\",\", filterL,\",\", filterL_lvl, \"} ?[y/n]\",sep=\"\"))\n#   #ans <- readline(\"\")\n#   #if (substr(ans, 1, 1) != \"n\"){\n#     outputFigsPrefix <- paste(c(\"TEST-\",(ci+1),\"__\",PDdata, ProteinQuantitation, filterL, filterL_lvl),sep=\"\",collapse=\"_\")\n#     perform_analysis()\n#     file.copy(c(\"curr_exp_design.txt\"), limma_output)\n#     setwd(limma_output)\n#     dir.create(outputFigsPrefix)\n#     files_produced<-list.files(\".\", \"\\\\.(pdf|txt)$\", full.names = TRUE)\n#     file.copy(files_produced, outputFigsPrefix)\n#     file.remove(files_produced)\n#     setwd(\"..\")\n#   #}  \n# }\n",
    "created" : 1398861569108.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "29|75|50|0|\n55|64|63|0|\n65|58|73|0|\n75|31|83|0|\n86|131|92|0|\n94|64|116|0|\n118|21|125|0|\n131|54|152|0|\n155|102|438|0|\n441|126|583|0|\n586|76|785|0|\n789|100|942|0|\n945|36|968|0|\n972|39|996|0|\n1003|92|1011|0|\n1014|137|1021|0|\n1024|48|1063|0|\n1066|51|1075|0|\n1078|124|1088|0|\n1093|1|1108|0|\n1111|107|1371|0|\n1375|85|1396|0|\n1404|143|1423|0|\n1441|30|1653|0|\n1477|76|1497|1|\n1507|97|1516|1|\n1611|77|1641|1|\n1641|68|1643|1|\n1477|76|1497|1|\n1507|97|1516|1|\n1611|77|1641|1|\n1641|68|1643|1|\n1655|47|1698|0|\n1699|31|1706|0|\n1707|24|1711|0|\n1713|45|1746|0|\n1747|29|1754|0|\n1755|22|1759|0|\n1839|29|1845|1|\n1848|26|1884|3|\n",
    "hash" : "4281508311",
    "id" : "64DC2820",
    "lastKnownWriteTime" : 1398861495,
    "path" : "~/ProteoSign/dev/msdiffexp/v2/MSdiffexp.R",
    "project_path" : "MSdiffexp.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}