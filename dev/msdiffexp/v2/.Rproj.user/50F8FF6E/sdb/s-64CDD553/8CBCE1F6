{
    "contents" : "# Based on a Progenesis LC-MS Limma Analysis script\n\n# Load the limma library so we can use it\n# Can be installed by running following commands in R\n#\n# source(\"http://www.bioconductor.org/biocLite.R\")\n# biocLite(\"limma\")\n# biocLite(\"statmod\")\n# -----\n# Install ggplot2 for nicer plots\n# install.packages(\"ggplot2\")\n# -----\n# install.packages(\"plyr\") \n#\n#\n\nlibrary(limma)\nlibrary(reshape)\nlibrary(plyr)\nlibrary(ggplot2)\n\n# FROM: http://musicroamer.com/blog/2011/01/16/r-tips-and-tricks-modified-pairs-plot/\n# Scatterplot matrix functionality\n\npanel.cor.scale <- function(x, y, digits=2, prefix=\"\", cex.cor)\n{\nusr <- par(\"usr\"); on.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr = (cor(x, y,use=\"pairwise\"))\ntxt <- format(c(r, 0.123456789), digits=digits)[1]\ntxt <- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex <- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex * abs(r))\n}\n\n\npanel.cor <- function(x, y, digits=2, prefix=\"\", cex.cor)\n{\nusr <- par(\"usr\"); on.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr = (cor(x, y,use=\"pairwise\"))\ntxt <- format(c(r, 0.123456789), digits=digits)[1]\ntxt <- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex <- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex )\n}\n\npanel.hist.breaks<--12:12\n\npanel.hist <- function(x, ...)\n{\nusr <- par(\"usr\"); on.exit(par(usr))\npar(usr = c(usr[1:2], 0, 1.5) )\n#h <- hist(x, plot = FALSE)\nh <- hist(x, breaks=panel.hist.breaks,plot = FALSE)\nbreaks <- h$breaks; nB <- length(breaks)\ny <- h$counts; y <- y/max(y)\nrect(breaks[-nB], 0, breaks[-1], y, col=\"cyan\", ...)\n}\n\n# FROM: http://www-personal.umich.edu/~ladamic/presentations/Rtutorial/Rtutorial.R\npanel.lmline = function (x, y, col = par(\"col\"), bg = NA, pch = par(\"pch\"), cex = 1, col.smooth = \"red\", ...){\n    points(x, y, pch = pch, col = col, bg = bg, cex = cex)\n    ok <- is.finite(x) & is.finite(y)\n    if (any(ok)) \n       abline(lm(y[ok] ~ x[ok]), \n           col = col.smooth, ...)\n}\n\npairs.panels <- function (x,y,smooth=TRUE,scale=FALSE,lm=FALSE)\n{\n\tif (smooth){\n\t\tif (scale) {\n\t\t\tif(lm){\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale,lower.panel=panel.lmline)\n\t\t\t}else{\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale,lower.panel=panel.smooth)\n\t\t\t}\n\t\t}else{\n\t\t\tif(lm){\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor,lower.panel=panel.lmline)\n\t\t\t}else{\n\t\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor,lower.panel=panel.smooth)\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(scale){\n\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale)\n\t\t}else{\n\t\t\tpairs(x,diag.panel=panel.hist,upper.panel=panel.cor)\n\t\t}\n\t}\n}\n\n\n\n# NOT CURRENTLY USED\n# FROM: http://wiki.stdout.org/rcookbook/Graphs/Multiple%20graphs%20on%20one%20page%20(ggplot2)/\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, by.row=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  require(grid)\n\n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n\n  numPlots = length(plots)\n\n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                    ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n\n if (numPlots==1) {\n    print(plots[[1]])\n\n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n\n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n\n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\nlm_eqn<-function(df){\n    m = lm(y ~ x, data=df);\n    eq <- substitute(italic(y) == a + b %.% italic(x)*\",\"~~italic(r)^2~\"=\"~r2, \n         list(a = format(coef(m)[1], digits = 2), \n              b = format(coef(m)[2], digits = 2), \n             r2 = format(summary(m)$r.squared, digits = 3)))\n    return(as.character(as.expression(eq)));\n}\n\n# to be used with apply on a limma-results data.frame\n# calculate mean, sd and N of ratios between available channels, i.e. !NA (possibly mixed replicates, arbitrary order)\n# Hcols_idxs, Mcols_idxs the column indexes of Heavy and Medium channels intensities respectively\n# x a limma-results data.frame row\ncalcRowStats<-function(x,Hcols_idxs,Mcols_idxs){\n\ttmp1<-as.numeric(x[Hcols_idxs])\n\ttmp2<-as.numeric(x[Mcols_idxs])\n\tminN<-min(length(which(!is.na(tmp1))),length(which(!is.na(tmp2))))\n\t#ratios<-tmp1[which(!is.na(tmp1))[1:minN]]-tmp2[which(!is.na(tmp2))[1:minN]]\n\tratios<-(tmp1-tmp2)\n\n\tm<-mean(ratios,na.rm=T)\n\tstd<-sd(ratios,na.rm=T)\n\t#TODO: generalize for any replicate strucutre\n\t#n_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\t#i_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\t#n_bioreps<-length(i_bioreps)\n\t#rep_structure_idxs<-lapply(i_bioreps,function(x) seq(from=x,to=x+n_techreps-1))\n\t\n\t#log2 ratio CV for each biorep ?, calculated according to \"CV for log-normally distributed data\" formula: http://en.wikipedia.org/wiki/Coefficient_of_variation\n\t#biorep_cv<-do.call(cbind, lapply(rep_structure_idxs,function(x) sqrt(sd((tmp2-tmp1)[x],na.rm=T)^2-1))) \n\t\n\t#log2 ratio CV for each techrep ?\n\t#rep_structure_idxs_2<-lapply(1:n_bioreps,function(x) i_bioreps+x-1)\t\n\t#biorep_cv<-do.call(cbind, lapply(rep_structure_idxs_2,function(x) sqrt(sd((tmp2-tmp1)[x],na.rm=T)^2-1))) \n\n\t#N<-length(ratios)\n\tN<-length(which(!is.na(ratios)|ratios==0))\n\t#avg.I<-log2(mean(2^c(tmp1[which(!is.na(tmp1))[1:minN]])+2^c(tmp2[which(!is.na(tmp2))[1:minN]])))\n\tavg.I<-log2(mean(sapply(1:length(Hcols_idxs),function(x) sum(c(2^tmp1[x],2^tmp2[x]),na.rm=T)),na.rm=T))\n\t#return(c(m,std,N,avg.I,ratios,rep(NA,length(Hcols_idxs)-N)))\n\treturn(c(m,std,N,avg.I,ratios))\n}\n\n\n# Produces S-plot, Volcano plot, MA plot and Scatterplot (matrix). Called by do_limma_analysis subroutine.\ndo_results_plots<-function(norm.median.intensities,time.point,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n\tresults<-read.table(paste(outputFigsPrefix,\"_STIMULATED-CTRL_\",time.point,\".txt\",sep=\"\"), header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\t#results$longID<-results$ID\n\t#results$ID<-sub(\"^([^;]*).*\",\"\\\\1\",results$ID)\n\trownames(results)<-results$ID\n\ttmp<-as.data.frame(t(norm.median.intensities))\n\trownames(tmp)<-colnames(norm.median.intensities)\n\t\n\tnsamples<-length(colnames(tmp))/2\n\tcolnames(tmp)<-apply(data.frame(cbind(rep(c(\"M\",\"H\"),each=nsamples),rep(1:nsamples))),1,function(x) paste(x['X1'],x['X2'],sep=\"\"))\n\tresults<-cbind(results,tmp)\n\tresults$N<-apply(results[,colnames(tmp)],1,function(x)(nsamples*2)-length(which(is.na(x))))\n\n\tresults<-results[!is.na(results$p.value.adj),]\n\tndiffexp<-nrow(results[results$p.value.adj<=0.05,])\n\t#limma volcano\n\t#volcanoplot(fit2, highlight=as.character(ndiffexp))\n\t#title(main=\"Log odds vs fold change STIMULATED-CTRL\", sub=\"Significant proteins highlighted\")\n\t\n\t#my plots\n\n\t# 1 - volcano - log odds vs log ratio\n\tif(exportFormat == \"pdf\"){\n\t\tpdf(file=paste(outputFigsPrefix,\"_volcano_\",time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n\t}\n\n\tHcols_idxs<-grep(\"^H\",colnames(results))\n\tMcols_idxs<-grep(\"^M\",colnames(results))\n\n\td<-data.frame(t(apply(results,1, function(x) calcRowStats(x,Hcols_idxs,Mcols_idxs))))\n\tcolnames(d)<-c(\"log2.avg.H.M\",\"log2.sd.H.M\",\"log2.N.H.M\",\"log2.avg.I\",apply(data.frame(cbind(rep(c(\"log2.H.M.\"),each=nsamples),rep(1:nsamples))),1,function(x) paste(x['X1'],x['X2'],sep=\"\")))\n\t#write.table(file=\"tmp.txt\",cbind(results,d),sep=\"\\t\")\n\n\tresults<-cbind(results,d)\n\n\t#sort data frame based on log2.avg.H.M\n\tresults<-results[with(results, order(log2.avg.H.M)),]\n\tresults$ID <- factor(results$ID, levels=unique(as.character(results$ID)))\n\tresults$nID<-1:nrow(results)\n\t#\n\n\trng<-range(melt(results[,colnames(results)[grep(\"log2.H.M.\",colnames(results))]])[[2]],na.rm=T)\n\tratiolim<-ceiling(max(abs(rng)))\n\tpanel.hist.breaks<--ratiolim:ratiolim\n\n\ttheme_set(theme_bw())\n\t# customized colorblind-friendly palette from http://wiki.stdout.org/rcookbook/Graphs/Colors%20(ggplot2)/\n\tcbPalette <- c(\"#999999\", \"#D55E00\", \"#E69F00\", \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\", \"#CC79A7\")\n\n\tp<-ggplot(data=results, aes(x=log2.avg.H.M, y=-log10(p.value.adj), colour=p.value.adj<=0.05)) +\n\t  geom_point(alpha=0.7, size=1.75) +\n\t  theme(legend.position = \"none\", axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0), plot.title = element_text(vjust=1.5, lineheight=.8, face=\"bold\")) +\n\t  xlim(c(-ratiolim, ratiolim)) + ylim(c(0, 6)) + scale_colour_manual(values=cbPalette) +\n\t  xlab(\"average log2 H/M\") + ylab(\"-log10 p-value\") + ggtitle(\"P-value vs Fold change\") +\n\t  geom_hline(aes(yintercept=-log10(0.05)), colour=\"#990000\", linetype=\"dashed\") +\n\t  geom_text(size=2.5, hjust=1, vjust=-0.5,aes(x=-4.2, y=-log10(0.05)), label=\"P-value=0.05\",colour=\"#990000\")# +\n\t  # geom_text(data=results[results$p.value.adj<=0.05 & abs(results$log2.avg.H.M)>2.9,],size=2.5, hjust=-0.2, vjust=0.2, aes(x=log2.avg.H.M, y=-log10(p.value.adj), label=ID), colour=\"black\")\n\tprint(p)\n\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_volcano_\",time.point,\".emf\",sep=\"\"),type=\"emf\")\n\t}\n\tdev.off()\n\t# 2 - value-ordered - log ratio\n\tif(exportFormat == \"pdf\"){\n\t\tpdf(file=paste(outputFigsPrefix,\"_value-ordered-log-ratio_\",time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n\t}\n\n\tp<-ggplot(data=results, aes(x=nID, y=log2.avg.H.M, colour=p.value.adj<=0.05)) +\n\t  geom_point(alpha=0.7, size=1.5) +\n\t  geom_errorbar(aes(ymin=log2.avg.H.M-log2.sd.H.M, ymax=log2.avg.H.M+log2.sd.H.M), width=1.5) +\n\t  theme(legend.position = \"none\", axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0), plot.title = element_text(vjust=1.5, lineheight=.8, face=\"bold\")) +\n\t  ylim(c(-ratiolim, ratiolim)) + scale_colour_manual(values=cbPalette) +\n\t  xlab(\"Protein ID\") + ylab(\"average log2 H/M\") + ggtitle(\"Value-ordered fold change\")# +\n\t  #geom_text(data=results[results$p.value.adj<=0.05 & abs(results$log2.avg.H.M)>2.9,],size=2, hjust=-0.2, vjust=0.2, aes(x=nID, y=log2.avg.H.M, label=ID), colour=\"black\")\n\tprint(p)\n\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_value-ordered-log-ratio_\",time.point,\".emf\",sep=\"\"),type=\"emf\")\n\t}\n\tdev.off()\n\t# 3 - MA plot\n\tif(exportFormat == \"pdf\"){\n\t\tpdf(file=paste(outputFigsPrefix,\"_MA_\",time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n\t}\n\n\tp<-ggplot(data=results, aes(x=log2.avg.I, y=log2.avg.H.M, colour=p.value.adj<=0.05)) +\n\t  geom_point(alpha=0.7, size=1.75) +\n\t  theme(legend.position = \"none\", axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0), plot.title = element_text(vjust=1.5, lineheight=.8, face=\"bold\")) +\n\t  ylim(c(-ratiolim, ratiolim)) + scale_colour_manual(values=cbPalette) +\n\t  xlab(\"M (average log2 Intensity)\") + ylab(\"A (average log2 H/M)\") + ggtitle(\"MA plot\")# +\n\t  #geom_text(data=results[results$p.value.adj<=0.05 & abs(results$log2.avg.H.M)>2.9,],size=2, hjust=-0.2, vjust=0.2, aes(x=log2.avg.I, y=log2.avg.H.M, label=ID), colour=\"black\")\n\tprint(p)\n\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_MA_\",time.point,\".emf\",sep=\"\"),type=\"emf\")\n\t}\n\tdev.off()\n\t# 4 - reproducibility plots & histograms\n\n\tallratios<-results[,colnames(results)[grep(\"log2.H.M.\",colnames(results))]]\n\tcolnames(allratios)<-sub(\"log2.H.M.\",\"log2(H/M) \",colnames(allratios))\n\n\tif(exportFormat == \"pdf\"){\n\t\tpdf(file=paste(outputFigsPrefix,\"_reproducibility_\",time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n\t}\n\n\tpairs.panels(allratios,scale=T,lm=T)\n\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_reproducibility_\",time.point,\".emf\",sep=\"\"),type=\"emf\")\n\t}\n\tdev.off()\n\n\t#n_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\t#i_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\t#n_bioreps<-length(i_bioreps)\n\t#rep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/2)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\n\t#colnames(allratios)<-rep_desc\n\t\n\t# write tables and finish\t\n\n\twrite.table(results,file=paste(outputFigsPrefix,\"_results_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",col.names=NA)\n\tprint(paste(\"Quantified proteins: \",nrow(results),\", Differentially expressed: \",ndiffexp,sep=\"\"))\n\n\t#diffexp<-results[results$p.value.adj <= 0.05,c(\"p.value.adj\",\"log2.avg.H.M\",\"log2.sd.H.M\",\"log2.N.H.M\",\"log2.avg.I\")]\n\tdiffexp<-results[,c(\"p.value.adj\",\"log2.avg.H.M\",\"log2.sd.H.M\",\"log2.N.H.M\",\"log2.avg.I\")]\n\tdiffexp$Protein<-rownames(diffexp)\n\tcolnames(diffexp)<-c(\"P-value\",\"avg log2 H/M\",\"std log2 H/M\",\"N log2 H/M\",\"avg log2 I\",\"Protein.IDs\")\n\tdiffexp<-diffexp[,c(\"Protein.IDs\",\"avg log2 H/M\",\"std log2 H/M\",\"P-value\", \"N log2 H/M\",\"avg log2 I\")]\n\ttmp_protein_groups<-protein_groups\n\tdiffexp<-merge(diffexp,tmp_protein_groups[,c(\"Protein.IDs\",sort(colnames(tmp_protein_groups)[grep(\"Ratio.H.M.count.\",colnames(tmp_protein_groups))]))],by=\"Protein.IDs\",all.x=T)\n\tdiffexp$Ratio.H.M.count.total<-rowSums(diffexp[,colnames(diffexp)[grep(\"Ratio.H.M.count.\",colnames(diffexp))]],na.rm=T)\n\twrite.table(diffexp[diffexp$\"P-value\"<= 0.05,],file=paste(outputFigsPrefix,\"_diffexp_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F,quote=F)\n\twrite.table(diffexp,file=paste(outputFigsPrefix,\"_limmaout_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F,quote=F)\n\n\treturn(results)\n}\n\n# Performs the differential expression analysis through limma, after quantile normalization.\ndo_limma_analysis<-function(working_pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n\t# Read the sample key\n\t# Assigns sample names (from the data file) to groups\n\t# Sample order must be the same as the main data file, but excludes technical\n\t# replicates as we will aggregate into one value per sample.\n\t\n\tsample.key <- read.delim(exp_design_fname, header=TRUE,row.names=1)\n\t\n\t# Extract protein quantitation columns only from quantitation input file\n\t# The quantitation data is in columns 10 to 90.\n\n\t#prot.intensities <- quantitation[,10:90]\n\tprot.intensities <- working_pgroups\n\n\t# Extract the protein names (imported from the data file) into a\n\t# separate list for future reference\n\n\tprot.names <- rownames(prot.intensities)\n\n\t# Take log2 of intensities\n\n\tlog.intensities  <- log2(prot.intensities)\n\n\tif(!file.exists(\"limma output\")){dir.create(\"limma output\")}\t\n\tsetwd(\"limma output\")\n\twrite.table(working_pgroups,file=paste(outputFigsPrefix,\"_limma-input_proteinGroups.txt\",sep=\"\"),sep=\"\\t\",row.names = TRUE)\n\n\tif(exportFormat == \"pdf\"){\n\t\tpdf(file=paste(outputFigsPrefix,\"_limma-graphs_\",time.point,\".pdf\",sep=\"\"),width=10, height=7, family = \"Helvetica\", pointsize=8)\n\t}\n\t# Box plot before normalisation\n\tboxplot(log.intensities)\n\ttitle(main=\"Intensities Before Normalisation\")\n\n\t# Perform quantile normalisation\n\n\tnorm.intensities <- normalizeBetweenArrays(data.matrix(log.intensities), method=\"quantile\");\n\t#norm.intensities <- cbind(normalizeBetweenArrays(data.matrix(log.intensities[,c(1:(length(rep_structure)/2))]), method=\"quantile\"),normalizeBetweenArrays(data.matrix(log.intensities[,c(((length(rep_structure)/2)+1):length(rep_structure))]), method=\"quantile\"));\n\n\t# Box plot after normalisation\n\tboxplot(norm.intensities)\n\ttitle(main=\"Intensities After Normalisation\")\n\n\t#---NOT USED---\n\t# Aggregate technical replicate measurements using median function\n\t# In this data there are 27 samples with 3 technical replicates each\n\n\t#norm.median.intensities <- aggregate(t(as.matrix(norm.intensities)), list(rep(1:27,each=3)), median)[,-1]\n\t#norm.median.intensities <- aggregate(t(as.matrix(norm.intensities)), list(rep(1:6,each=3)), function(x) median(x))[,-1]\n\t#norm.median.intensities <- aggregate(t(as.matrix(norm.intensities)), list(rep_structure), median)[,-1]\n\t#--------------\n\t\n\t#norm.median.intensities <- aggregate(t(as.matrix(norm.intensities)), list(1:length(rep_structure)), median)[,-1]\n\tnorm.median.intensities<-as.data.frame(t(as.matrix(norm.intensities)))\n\n\t# Assign row names to our aggregated intensities from the sample key\n\n\trow.names(norm.median.intensities) <- row.names(sample.key)\n\n\t# Setup design matrix\n\t# This specifies the design of the experiment for limma, replicating\n\t# the info in the sample key, but representing it in a matrix format\n\n\tdesign <- model.matrix(~0 + factor(sample.key$Category) )\n\tcolnames(design) <- levels(sample.key$Category)\n\n\tfit<-\"\"\n\tn_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\tif(n_techreps > 0){\t# if we have technical replicates (duplicated elements in rep_structure)\n\t\t# technical replication specification\n\t\tcorfit <- duplicateCorrelation(t(norm.median.intensities), design=design, ndups=1, block = rep_structure, trim = duplicateCorrelation_trim)\n\t\t# Fit the limma model to the data\n\t\t# Pass the protein names to limma as the genes option\n\t\tfit <- lmFit(t(norm.median.intensities), design, genes=prot.names, block = rep_structure, cor = corfit$consensus)\n\t}else{\n\t\tfit <- lmFit(t(norm.median.intensities), design, genes=prot.names)\n\t}\n\n\t# Setup contrast matrix\n\t# The contrast matrix specifies what comparisons we want to make between groups.\n\t# Here there are two groups AS and CONTROL so we compare them. We pass the design\n\t# matrix as the levels option to the makeContrasts function.\n\n\t#contrasts <- makeContrasts(AS-CONTROL, levels=design)\n\tcontrasts <- makeContrasts(STIMULATED-CONTROL, levels=design)\n\n\t# Apply contrast matrix and do empirical bayes analysis to get p-values etc.\n\n\tfit2 <- contrasts.fit(fit, contrasts)\n\tfit2 <- eBayes(fit2)\n\n\t# Make volcano plot\n\n\t#volcanoplot(fit2, highlight=\"20\")\n\t#title(main=\"Log odds vs fold change AS-CTRL\", sub=\"Top 20 most significant proteins highlighted\")\n\t#title(main=\"Log odds vs fold change STIMULATED-CTRL\", sub=\"Top 20 most significant proteins highlighted\")\n\n\t# Plot a Histogram of co-efficients (log2 ratio)\n\t#hist(fit2$coefficients,main=\"Log2 Fold Change AS-CTRL\", xlab=\"Log2 Fold Change\", breaks=50 )\n\thist(fit2$coefficients,main=\"Log2 Fold Change STIMULATED-CTRL\", xlab=\"Log2 Fold Change\", breaks=50 )\n\t\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_limma-graphs_\",time.point,\"_hist.emf\",sep=\"\"),type=\"emf\")\n\t}\n\n\t# Do an MA Plot (mean of log2 intensities vs log2 ratio)\n\t# Important to inspect the MA plot to ensures that the ratio does not depend on\n\t# the intensity of the protein. This shouldn't happen if the data was normalised\n\t# successfully, and should be unusual in SILAC / label-free experiments.\n\n\tplotMA(fit2)\n\n\t# Add a line at y=0 to the MA plot. The clouds of points should be centred around y=0\n\t# if most proteins are unchanges and normalisation worked well.\n\n\tabline(h=0)\n\n\tif(exportFormat == \"emf\"){\n\t\tsavePlot(filename=paste(outputFigsPrefix,\"_limma-graphs_\",time.point,\"_MA.emf\",sep=\"\"),type=\"emf\")\n\t}\n\n\tdev.off()\n\n\t# Output analysis details to file\n\t# asjust=\"BH\" means adjust the calculated p-values for multiple testing using\n\t# the Benjamini Hochberg method (FDR)\n\n\t#write.fit(fit2, file=\"AS-CTRL.txt\", adjust=\"BH\")\n\twrite.fit(fit2, file=paste(outputFigsPrefix,\"_STIMULATED-CTRL_\",time.point,\".txt\",sep=\"\"), adjust=\"BH\")\n\n\tresults<-do_results_plots(norm.median.intensities, time.point, exportFormat=exportFormat,outputFigsPrefix=outputFigsPrefix)\n\tsetwd(\"..\")\n\treturn(results)\n}\n\n# Reads MaxQuant (1.3.0.5) proteinGroups table, discards information not required (for downstream analysis) and returns the table\nread.pgroups_v2<-function(fname,time.point,filterL=F,evidence_fname=\"\",keepEvidenceIDs=F){\n\tif(filterL){\n\t\tpgroups<-filter_unlabeled_proteins(fname,evidence_fname)\n\t}else{\n\t\tpgroups<-read.table(fname, header = T, sep = \"\\t\",quote='',stringsAsFactors = FALSE)\n\t}\n\tpgroups<-pgroups[pgroups$Reverse != \"+\" & pgroups$Contaminant != \"+\", ]\n\t#pgroups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.IDs),\" ...] (\",pgroups$Proteins,\")\",sep=\"\")\n\tpgroups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.IDs),\" ...]\",sep=\"\")\n\tif(keepEvidenceIDs)\n\t{\n\t\tpgroups<-pgroups[,c(\"Protein.IDs\",\"Protein.names\",\"Proteins\",sort(colnames(pgroups)[grep(\"Razor...unique.peptides.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Peptides.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Ratio.H.M.count.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Intensity.(M|H).b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Ratio.H.M.b\",colnames(pgroups))]),\"Evidence.IDs\")]\n\t}\n\telse{\n\t\tpgroups<-pgroups[,c(\"Protein.IDs\",\"Protein.names\",\"Proteins\",sort(colnames(pgroups)[grep(\"Razor...unique.peptides.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Peptides.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Ratio.H.M.count.b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Intensity.(M|H).b\",colnames(pgroups))]),sort(colnames(pgroups)[grep(\"Ratio.H.M.b\",colnames(pgroups))]))]\n\t}\n\tcolnames(pgroups[grep(\"Razor...unique.peptides.b\",colnames(pgroups))])<-paste(sub(\"\\\\.\\\\.\\\\.\",\"\\\\.\",colnames(pgroups[grep(\"Razor...unique.peptides.b\",colnames(pgroups))]))) \n\tpgroups$time.point<-time.point\n\tprint(paste(\"Identified proteins (w/o contaminants): \",nrow(pgroups[pgroups$time.point == time.point,]),\" (\",time.point,\")\",sep=\"\"))\n\treturn(pgroups)\n}\n\n# Reads PD (1.3) psms table*, groups peptides according to the first leading protein of the protein group they belong to\n# and returns an Protein ID along with a replicate number. This can be imported in Excel later, do a pivot table and\n# obtain the reproducibility of identification between replicates.\n#\n#* Although PD exports a proteinGroups table, it is not usable\n# as it is not known how protein grouping is performed. Because protein group id and peptide id information has to\n# be preserved for various kinds of calculations a basic grouping is done manually. Note for quantitation, this\n# grouping does not affect any kind of calculation as only unique peptides are used which have always an 1:1\n# correspondence with protein IDs (so no grouping).\n#TODO: generalize for any replicate structure, as it now assumes 3 biological x 3 technical replicates (nested)\nid_Venn3_pgroups_PD_doGroupIDs<-function(fname,evidence_fname,time.point,rep_structure,filterL=F,rep_order=NA){\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t#Generate Evidence ID\n\tevidence$id<-1:(nrow(evidence))\t\n\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",evidence$Protein.Group.Accessions)\n\ttmp1<-unlist(lapply(evidence$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tevidence$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tevidence$Protein.IDs<-paste(evidence$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tevidence$Protein.Group.Accessions<-evidence$Protein.IDs\n\n\t#write.table(evidence,file=\"tmp.txt\",row.names=F,sep=\"\\t\")\n\tevidence$Spectrum.File<-factor(evidence$Spectrum.File)\n\n\t#Sum Quan channels individually for each raw file\n\t#subtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) c(Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy))))\n\t#WARNING: below line assumes that ratio (or peptide) quantification counts are the same for all SILAC partners (that's why only one column, the Heavy, is considered as the representative, because it makes no difference). This happens when in PD, in the quantification options the \"re-quantify\" (it is called something else) option is selected\n\tsubtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) data.frame(n.Peptides=sum(!is.na(x$Sequence))))\n\n\tmelted_subtotals<-melt(subtotals)\t\n\n\tn_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\tn_bioreps<-length(i_bioreps)\n\t\n\tmelted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n\n\t#WARNING: Here it is assumed that the lexigographic order of raw file names is the order of acquisition (usually true)\n\t\n\trep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/2)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\tif(!is.na(rep_order)){\n\t\to<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n\t\trep_desc<-rep_desc[o]\n\t}\n\n\tlevels(melted_subtotals$Spectrum.File)<-rep_desc\n\n\tpgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.Group.Accessions,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n\tcolnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))]<-sub(\"(.*)\\\\.n\\\\.Peptides\",\"Peptides.\\\\1\",colnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))])\n\tpgroups$Protein.IDs<-row.names(pgroups)\n\n\tpgroups$time.point<-time.point\n\t\n\tpgroups<-pgroups[pgroups$Protein.IDs!=\" [ ...] [ ...]\",]\n\tprint(paste(\"Identified proteins: \",nrow(pgroups),\" (\",time.point,\")\",sep=\"\"))\n\n\tb1<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b1\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb1$rep<-\"1\"\n\tb2<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b2\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb2$rep<-\"2\"\n\tb3<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b3\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb3$rep<-\"3\"\n\tvenn_data<-rbind(b1,b2,b3)\n\treturn(venn_data)\n}\n\n\n# Like the (see) above function, but without protein grouping.\n#TODO: generalize for any replicate structure, as it now assumes 3 biological x 3 technical replicates (nested)\nid_Venn3_pgroups_PD<-function(fname,evidence_fname,time.point,rep_structure,filterL=F,rep_order=NA){\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t#Generate Evidence ID\n\tevidence$id<-1:(nrow(evidence))\t\n\tallproteins<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions),length))\n\tallproteins<-data.frame(Protein.IDs=names(allproteins[[1]]),stringsAsFactors=F)\n\n\ttmpdf<-evidence[,c(\"Protein.Group.Accessions\",\"Protein.Descriptions\")]\n\tcolnames(tmpdf)<-c(\"Protein.IDs\",\"Protein.Descriptions\")\n\ttmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]\n\tallproteins<-merge(allproteins,tmpdf,by=\"Protein.IDs\",all.x=T)\n\t\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",allproteins$Protein.IDs)\n\ttmp1<-unlist(lapply(allproteins$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tallproteins$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tallproteins$Protein.IDs<-paste(allproteins$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tallproteins<-allproteins[!duplicated(allproteins$Protein.IDs),]\n\t#write.table(allproteins,file=\"tmp.txt\",row.names=F,sep=\"\\t\")\n\n\tprint(paste(\"Identified proteins: \",nrow(allproteins),\" (\",time.point,\")\",sep=\"\"))\n\n\tevidence$Spectrum.File<-factor(evidence$Spectrum.File)\n\n\t#Sum Quan channels individually for each raw file\n\t#subtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) c(Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy))))\n\t#WARNING: below line assumes that ratio (or peptide) quantification counts are the same for all SILAC partners (that's why only one column, the Heavy, is considered as the representative, because it makes no difference). This happens when in PD, in the quantification options the \"re-quantify\" (it is called something else) option is selected\n\tsubtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) data.frame(n.Peptides=sum(!is.na(x$Sequence))))\n\n\tmelted_subtotals<-melt(subtotals)\t\n\n\t#write.table(tmp,file=\"tmp.txt\",row.names=F,sep=\"\\t\")\n\t#write.table(evidence,file=\"tmp2.txt\",row.names=F,sep=\"\\t\")\n\n\tn_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\tn_bioreps<-length(i_bioreps)\n\t\n\tmelted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n\n\t#WARNING: Here it is assumed that the lexigographic order of raw file names is the order of acquisition (usually true)\n\t\n\trep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/2)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\tif(!is.na(rep_order)){\n\t\to<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n\t\trep_desc<-rep_desc[o]\n\t}\n\n\tlevels(melted_subtotals$Spectrum.File)<-rep_desc\n\n\tpgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.Group.Accessions,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n\tcolnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))]<-sub(\"(.*)\\\\.n\\\\.Peptides\",\"Peptides.\\\\1\",colnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))])\n\tpgroups$Protein.IDs<-row.names(pgroups)\n\n\ttmpdf<-evidence[,c(\"Protein.Group.Accessions\",\"Protein.Descriptions\")]\n\tcolnames(tmpdf)<-c(\"Protein.IDs\",\"Protein.Descriptions\")\n\ttmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]\n\tpgroups<-merge(pgroups,tmpdf,by=\"Protein.IDs\",all.x=T)\n\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.IDs)\n\ttmp1<-unlist(lapply(pgroups$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tpgroups$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tpgroups$Protein.IDs<-paste(pgroups$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tpgroups<-pgroups[,!(colnames(pgroups) %in% c(\"Protein.Descriptions\"))]\n\n\n\tpgroups$time.point<-time.point\n\tprint(paste(\"Identified proteins: \",nrow(pgroups),\" (\",time.point,\")\",sep=\"\"))\n\n\tpgroups<-pgroups[pgroups$Protein.IDs!=\" [ ...] [ ...]\",]\n\trow.names(pgroups)<-pgroups$Protein.IDs\n\t\t\n\n\tb1<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b1\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb1$rep<-\"1\"\n\tb2<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b2\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb2$rep<-\"2\"\n\tb3<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b3\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb3$rep<-\"3\"\n\tvenn_data<-rbind(b1,b2,b3)\n\treturn(venn_data)\n}\n\n#Like the above, but for MaxQuant data\n#TODO: generalize for any replicate structure, as it now assumes 3 biological x 3 technical replicates (nested)\nid_Venn3_pgroups<-function(pgroups){\n\tb1<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b1\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb1$rep<-\"1\"\n\tb2<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b2\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb2$rep<-\"2\"\n\tb3<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(\"Peptides.b3\",colnames(pgroups))]],na.rm=T)>0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb3$rep<-\"3\"\n\tvenn_data<-rbind(b1,b2,b3)\n\treturn(venn_data)\n}\n\n#Like the above, but for quantified proteins (quantified means having a Ratio.H.M.count greater than 0 for each replicate.\n#TODO: generalize for any replicate structure, as it now assumes 3 biological x 3 technical replicates (nested)\nquant_Venn3_pgroups<-function(pgroups){\n\tb1<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,c(\"Ratio.H.M.count.b1t1\",\"Ratio.H.M.count.b1t2\",\"Ratio.H.M.count.b1t3\")], na.rm=T) > 0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb1$rep<-\"1\"\n\tb2<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,c(\"Ratio.H.M.count.b2t1\",\"Ratio.H.M.count.b2t2\",\"Ratio.H.M.count.b2t3\")], na.rm=T) > 0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb2$rep<-\"2\"\n\tb3<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,c(\"Ratio.H.M.count.b3t1\",\"Ratio.H.M.count.b3t2\",\"Ratio.H.M.count.b3t3\")], na.rm=T) > 0,c(\"Protein.IDs\")],stringsAsFactors=F)\n\tb3$rep<-\"3\"\n\tvenn_data<-rbind(b1,b2,b3)\n\treturn(venn_data)\n}\n\n\n# MaxQuant (1.3.0.5) only\n# Used to generate Venn data for showing protein ID reproducibility between identified and quantified proteins.\n# Quantified proteins using this function will be considered only those with a total Ratio.H.M.count > 2 across replicates\n#TODO: generalize for any replicate structure for the identified proteins, as it now assumes 3 biological x 3 technical replicates (nested)\ndo_generate_Venn3_data_quant_filter_1<-function(pgroups,time.point,outputFigsPrefix=\"\"){\n\tsetwd(\"limma output\")\n\t#venn_data<-quant_Venn3_pgroups(pgroups[pgroups$time.point == time.point,])\n\tvenn_data<-quant_Venn3_pgroups(pgroups_filter_1_v2(pgroups[pgroups$time.point == time.point,],time.point))\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_quant_venn3-data-relaxed_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tvenn_data<-id_Venn3_pgroups(pgroups[pgroups$time.point == time.point,])\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_id_venn3-data_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tsetwd(\"..\")\n}\n\n# MaxQuant (1.3.0.5) only\n# Like the above, apart from the quant filter.\n# Quantified proteins using this function will be considered only those with a total Ratio.H.M.count > 2 for at least two replicates\n#TODO: generalize for any replicate structure for the identified proteins, as it now assumes 3 biological x 3 technical replicates (nested)\ndo_generate_Venn3_data_quant_filter_2reps<-function(pgroups,time.point,outputFigsPrefix=\"\"){\n\tsetwd(\"limma output\")\n\t#venn_data<-quant_Venn3_pgroups(pgroups[pgroups$time.point == time.point,])\n\tvenn_data<-quant_Venn3_pgroups(pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,],time.point))\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_quant_venn3-data-2reps_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tvenn_data<-id_Venn3_pgroups(pgroups[pgroups$time.point == time.point,])\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_id_venn3-data_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tsetwd(\"..\")\n}\n\n# Like the above, but for PD (1.3)\ndo_generate_Venn3_data_quant_filter_2reps_PD<-function(pgroups,time.point,evidence_fname,rep_structure,rep_order=NA,outputFigsPrefix=\"\",grouping=F){\n\tif(grouping){\n\t\tvenn_data<-id_Venn3_pgroups_PD_doGroupIDs(\"\",evidence_fname,time.point,rep_structure,rep_order)\n\t}else{\n\t\tvenn_data<-id_Venn3_pgroups_PD(\"\",evidence_fname,time.point,rep_structure,rep_order)\n\t}\n\tsetwd(\"limma output\")\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_id_venn3-data_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tvenn_data<-quant_Venn3_pgroups(pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,],time.point))\n\twrite.table(venn_data,file=paste(outputFigsPrefix,\"_quant_venn3-data-2reps_\",time.point,\".txt\",sep=\"\"),sep=\"\\t\",row.names=F)\n\tsetwd(\"..\")\n}\n\n#Basic quant filter, at least 3 Ratio.H.M.counts across all replicates\npgroups_filter_1_v2<-function(pgroups){\n\treps_cols<-colnames(pgroups)[grep(\"Ratio.H.M.count.\",colnames(pgroups))]\n\tpgroups_quant<-pgroups[rowSums(pgroups[,reps_cols],na.rm=T)>2,]\n\n\t#replace 0 with NA\n\tpgroups_quant<-as.data.frame(lapply(pgroups_quant, function(x){replace(x, x == 0, NA)}),stringsAsFactors = FALSE)\n\tpgroups_quant<-as.data.frame(lapply(pgroups_quant, function(x){replace(x, is.nan(x), NA)}),stringsAsFactors = FALSE)\n\n\tprint(paste(\"Quantified proteins (>2 peptides in total): \",nrow(pgroups_quant[pgroups_quant$time.point == time.point,]),\" (\",time.point,\")\",sep=\"\"))\n\treturn(pgroups_quant)\n}\n\n#More stringent quant filter, require quantitation in at least 2 replicates\npgroups_filter_2reps_v2<-function(pgroups,reps){\t#reps is dummy here\n\tn_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\tn_bioreps<-length(i_bioreps)\n\treps_cols<-colnames(pgroups)[grep(\"Ratio.H.M.count.\",colnames(pgroups))]\n\t\n\t\n\tratioRepTruth<-c()\n\tfor(rep_cols_i in i_bioreps){\n\t\tcurr_techreps_cols<-reps_cols[c(rep(rep_cols_i,n_techreps)+(0:(n_techreps-1)))]\n\t\tratioRepTruth<-cbind(ratioRepTruth,rowSums(pgroups[,curr_techreps_cols],na.rm=T)>2)\n\t}\n\tfilter<-apply(ratioRepTruth,1,function(x) length(which(x)))\n\tpgroups_intersect<-pgroups[filter>1,]\n\t\n\t#replace 0 with NA\n\tpgroups_intersect<-as.data.frame(lapply(pgroups_intersect, function(x){replace(x, x == 0, NA)}),stringsAsFactors = FALSE)\n\tpgroups_intersect<-as.data.frame(lapply(pgroups_intersect, function(x){replace(x, is.nan(x), NA)}),stringsAsFactors = FALSE)\n\n\tprint(paste(\"Quantified proteins (>2 peptides/\",n_techreps,\" injections in at least \",2,\" replicates): \",nrow(pgroups_intersect[pgroups_intersect$time.point == time.point,]),\" (\",time.point,\")\",sep=\"\"))\n\treturn(pgroups_intersect)\n}\n\n#Prepare protein intensity table for differential expression analysis (the format limma requires)\nprepare_working_pgroups<-function(working_pgroups){\n\trownames(working_pgroups)<-working_pgroups$Protein.IDs\n\tinten_cols<-c(sort(colnames(working_pgroups)[grep(\"Intensity.M.b\",colnames(working_pgroups))]),sort(colnames(working_pgroups)[grep(\"Intensity.H.b\",colnames(working_pgroups))]))\n\tworking_pgroups<-working_pgroups[,inten_cols]\n\tcolnames(working_pgroups)<-sub(\"Intensity\\\\.\",\"\",inten_cols)\n\treturn(working_pgroups)\n}\n\n# NOT SUPPORTED/MAINTAINED ANY MORE\n# Like the above, but just for a specified replicate\nprepare_working_pgroups_rep<-function(working_pgroups,rep){\n\trownames(working_pgroups)<-working_pgroups$Protein.IDs\n\tinten_cols<-c(sort(colnames(working_pgroups)[grep(paste(\"Intensity.M.b\",as.character(rep),sep=\"\"),colnames(working_pgroups))]),sort(colnames(working_pgroups)[grep(paste(\"Intensity.H.b\",as.character(rep),sep=\"\"),colnames(working_pgroups))]))\n\tworking_pgroups<-working_pgroups[,inten_cols]\n\tcolnames(working_pgroups)<-sub(\"Intensity\\\\.\",\"\",inten_cols)\n\treturn(working_pgroups)\n}\n\n\n#Perform the analysis using the basic quant filter (see above pgroups_filter_1_v2)\ndo_analyse_all_relaxed_v2<-function(pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n\tworking_pgroups<-pgroups_filter_1_v2(pgroups[pgroups$time.point == time.point,])\n\tworking_pgroups<-prepare_working_pgroups(working_pgroups)\n\toutputFigsPrefix<-paste(outputFigsPrefix,\"-all-relaxed\",sep=\"\")\n\treturn(do_limma_analysis(working_pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=outputFigsPrefix))\n}\n\n#Perform the analysis using the more stringent quant filter (see above pgroups_filter_2reps_v2)\ndo_analyse_all_2reps_v2<-function(pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=\"\"){\n\tworking_pgroups<-pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,])\n\tworking_pgroups<-prepare_working_pgroups(working_pgroups)\n\toutputFigsPrefix<-paste(outputFigsPrefix,\"-all-2reps\",sep=\"\")\n\treturn(do_limma_analysis(working_pgroups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=outputFigsPrefix))\n}\n\n#MaxQuant (1.3.0.5) only\n#Gets rid of proteins identified just by \"Light\" peptides (100% L).\n#Requires to read the both the proteinGroups and the evidence file\nfilter_unlabeled_proteins<-function(protein_groups_fname,evidence_fname)\n{\n\tprotein_groups<-read.table(protein_groups_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\tN_proteins_before<-nrow(protein_groups)\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\tN_peptides_before<-nrow(evidence)\n\t#protein_groups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.IDs),\" ...]\",sep=\"\")\n\t#protein_groups$Protein.IDs<-gsub(\"\\\"\",\"\",protein_groups$Protein.IDs)\n\tevidence<-evidence[,c(\"id\",\"Protein.group.IDs\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error..ppm.\",\"K.Count\",\"R.Count\")]\n\tevidence<-evidence[!is.na(evidence$Labeling.State) & evidence$Labeling.State > 0,]\n\tN_peptides_after<-nrow(evidence)\n\tevidence_pgroups<-as.data.frame(do.call(rbind,apply(evidence,1,function(x) cbind(x[\"id\"],unlist(strsplit(x[\"Protein.group.IDs\"],\";\"))))),stringsAsFactors=F)\n\tcolnames(evidence_pgroups)<-c(\"id\",\"Protein.group.IDs\")\n\trow.names(evidence_pgroups)<-NULL\n\tprotein_groups<-protein_groups[protein_groups$id %in% evidence_pgroups$Protein.group.IDs,]\n\tN_proteins_after<-nrow(protein_groups)\n\tprint(paste(\"Before L peptide filtering (proteins, peptides): \",N_proteins_before,\", \",N_peptides_before,\". After: \",N_proteins_after,\", \",N_peptides_after,\".\",sep=\"\"))\n\treturn(protein_groups)\n}\n\n# PD (1.3) only\ngetLMH<-function(evidence){\n\tLMH<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions,LMH=evidence$Quan.Channel),length))\n\treturn(LMH)\n}\n\n# PD (1.3) only\ngetLMH_Proteins<-function(LMH){\n\treturn(c(sum(!is.na(LMH$Light)),sum(!is.na(LMH$Medium)),sum(!is.na(LMH$Heavy))))\n}\n\n# PD (1.3) only\ngetLMH_Peptides<-function(LMH){\n\treturn(c(sum(LMH$Light,na.rm=T),sum(LMH$Medium,na.rm=T),sum(LMH$Heavy,na.rm=T)))\n}\n\n# PD (1.3) only\n# Like the read.pgroups_v2 for MaxQuant data. \nread.pgroups_v2_PD<-function(fname,evidence_fname,time.point,rep_structure,filterL=F,keepEvidenceIDs=F,rep_order=NA){\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t#Generate Evidence ID\n\tevidence$id<-1:(nrow(evidence))\t\n\tallproteins<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions),length))\n\tallproteins<-data.frame(Protein.IDs=names(allproteins[[1]]),stringsAsFactors=F)\n\n\ttmpdf<-evidence[,c(\"Protein.Group.Accessions\",\"Protein.Descriptions\")]\n\tcolnames(tmpdf)<-c(\"Protein.IDs\",\"Protein.Descriptions\")\n\ttmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]\n\tallproteins<-merge(allproteins,tmpdf,by=\"Protein.IDs\",all.x=T)\n\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",allproteins$Protein.IDs)\n\ttmp1<-unlist(lapply(allproteins$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tallproteins$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tallproteins$Protein.IDs<-paste(allproteins$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tallproteins<-allproteins[!duplicated(allproteins$Protein.IDs),]\n\n\n\n\tsubtotals_MH<-ddply(evidence,c(\"Protein.Group.Accessions\"),function(x) data.frame(Light=length(which(!grepl(\"Label:\",x$Modifications))),Medium=length(which(grepl(\"Label:2H\\\\(4\\\\)\\\\)\",x)|grepl(\"Label:13C\\\\(6\\\\)\\\\)\",x$Modifications))),Heavy=length(which(grepl(\"Label:13C\\\\(6\\\\)15N\\\\(2\\\\)\",x)|grepl(\"Label:13C\\\\(6\\\\)15N\\\\(4\\\\)\",x$Modifications)))))\n\tsubtotals_MH$MH_percentage<-apply(subtotals_MH,1,function(x){\n\t\t\t\t\t\tLMH<-as.numeric(x[-1])\n\t\t\t\t\t\tif(LMH[1]==0){\n\t\t\t\t\t\t\treturn(100)\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn(100*sum(LMH[-1])/sum(LMH))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t)\n      colnames(subtotals_MH)[1]<-\"Protein.IDs\"\n\n\tprint(paste(\"Identified proteins: \",nrow(allproteins),\" (\",time.point,\")\",sep=\"\"))\n\tevidence<-evidence[evidence$Quan.Info==\"Unique\" & evidence$Quan.Usage==\"Used\",]\n\t\n\t#filter out peptides where medium and heavy intensity are identical (Heavy.Medium==1) & (X..Missing.Channels==2) & (Quan.Channel==\"Light\"), meaning only the light peak was found\n\tevidence[is.na(evidence$Heavy.Medium),c(\"Heavy.Medium\")]<-0\n\tevidence[is.na(evidence$X..Missing.Channels),c(\"X..Missing.Channels\")]<-0\n\tevidence<-evidence[evidence$Heavy.Medium!=1 & evidence$X..Missing.Channels!=2,]\n\tevidence[evidence$Heavy.Medium==0,c(\"Heavy.Medium\")]<-NA\t#restore back to previous format, change was just for the above condition to work (with NAs it doesn't)\n\n\tLMH<-getLMH(evidence)\n\tn_MH_Proteins<-nrow(LMH[rowSums(LMH[,c(\"Medium\",\"Heavy\")],na.rm=T)>0,]) #Sum of M and H peptides > 0\n\tn_Peptides<-nrow(as.data.frame(tapply(evidence$Sequence,list(Acc=evidence$Sequence),length)))\n\t\n\tif(filterL){\n\t\tevidence<-evidence[evidence$Quan.Channel!=\"Light\",]\n\t\tLMH2<-getLMH(evidence)\n\t\tn_MH_Peptides<-nrow(as.data.frame(tapply(evidence$Sequence,list(Acc=evidence$Sequence),length)))\n\t\tprint(paste(\"Before L peptide filtering (proteins, peptides): \",nrow(LMH),\", \",n_Peptides,\". After: \",nrow(LMH2),\", \",n_MH_Peptides,\".\",sep=\"\"))\n\t\tLMH<-LMH2\n\t\tn_Peptides<-n_MH_Peptides\n\t}\n\tprint(paste(\"Subtotals input (proteins, peptides): \",nrow(LMH),\", \",n_Peptides,\".\",sep=\"\"))\n\t#tmp<-as.data.frame(tapply(evidence$Sequence,list(Seq=evidence$Sequence),length))\n\n\tevidence$Spectrum.File<-factor(evidence$Spectrum.File)\n\n\t#Sum Quan channels individually for each raw file\n\t#subtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) c(Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy))))\n\t#WARNING: below line assumes that ratio (or peptide) quantification counts are the same for all SILAC partners (that's why only one column, the Heavy, is considered as the representative, because it makes no difference). This happens when in PD, in the quantification options the \"re-quantify\" (it is called something else) option is selected\n\tsubtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) data.frame(Evidence.IDs=paste(x$id,collapse=\";\"),Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy))))\n\tall_evidence_ids<-ddply(subtotals,c(\"Protein.Group.Accessions\"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=\";\")))\n\tcolnames(all_evidence_ids)<-c(\"Protein.IDs\",\"Evidence.IDs\")\n\n\tmelted_subtotals<-melt(subtotals)\t\n\n\t#write.table(tmp,file=\"tmp.txt\",row.names=F,sep=\"\\t\")\n\t#write.table(evidence,file=\"tmp2.txt\",row.names=F,sep=\"\\t\")\n\n\tn_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\tn_bioreps<-length(i_bioreps)\n\t\n\tmelted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n\n\t#WARNING: Here it is assumed that the lexigographic order of raw file names is the order of acquisition (usually true)\n\t\n\trep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/2)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\tif(!is.na(rep_order)){\n\t\to<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n\t\trep_desc<-rep_desc[o]\n\t}\n\n\tlevels(melted_subtotals$Spectrum.File)<-rep_desc\n\n\tpgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.Group.Accessions,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n\tcolnames(pgroups)[grep(\"\\\\.Light\",colnames(pgroups))]<-sub(\"(.*)\\\\.Light\",\"Intensity.L.\\\\1\",colnames(pgroups)[grep(\"\\\\.Light\",colnames(pgroups))])\n\tcolnames(pgroups)[grep(\"\\\\.Medium\",colnames(pgroups))]<-sub(\"(.*)\\\\.Medium\",\"Intensity.M.\\\\1\",colnames(pgroups)[grep(\"\\\\.Medium\",colnames(pgroups))])\n\tcolnames(pgroups)[grep(\"\\\\.Heavy\",colnames(pgroups))]<-sub(\"(.*)\\\\.Heavy\",\"Intensity.H.\\\\1\",colnames(pgroups)[grep(\"\\\\.Heavy\",colnames(pgroups))])\n\n\tcolnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))]<-sub(\"(.*)\\\\.n\\\\.Peptides\",\"Ratio.H.M.count.\\\\1\",colnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))])\n\tpgroups<-pgroups[,!(colnames(pgroups) %in% colnames(pgroups)[grep(\"Intensity\\\\.L\\\\.\",colnames(pgroups))])]\n\tpgroups$Protein.IDs<-row.names(pgroups)\n\n\tif(keepEvidenceIDs)\n\t{\n\t\tpgroups<-merge(pgroups,all_evidence_ids,by=\"Protein.IDs\",all.x=T)\n\t}\n\n\n\ttmpdf<-evidence[,c(\"Protein.Group.Accessions\",\"Protein.Descriptions\")]\n\tcolnames(tmpdf)<-c(\"Protein.IDs\",\"Protein.Descriptions\")\n\ttmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]\n\tpgroups<-merge(pgroups,tmpdf,by=\"Protein.IDs\",all.x=T)\n\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",pgroups$Protein.IDs)\n\ttmp1<-unlist(lapply(pgroups$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tpgroups$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tpgroups$Protein.IDs<-paste(pgroups$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tpgroups<-pgroups[,!(colnames(pgroups) %in% c(\"Protein.Descriptions\"))]\n\n\t\n\n\tpgroups$time.point<-time.point\n\tpgroups<-merge(pgroups,subtotals_MH,by=\"Protein.IDs\",all.x=T)\n\n\tprint(paste(\"Quantifiable proteins: \",nrow(pgroups),\" (\",time.point,\")\",sep=\"\"))\n\n\trow.names(pgroups)<-pgroups$Protein.IDs\n\treturn(pgroups)\n}\n\n# Like the read.pgroups_v2_PD with protein grouping enabled (see above id_Venn3_pgroups_PD_doGroupIDs) \nread.pgroups_v2_PD_doGroupIDs<-function(fname,evidence_fname,time.point,rep_structure,filterL=F,keepEvidenceIDs=F,rep_order=NA){\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F,comment.char = \"\")\n\t#Generate Evidence ID\n\tevidence$id<-1:(nrow(evidence))\t\n\ttmp<-sub(\"^([^;]*).*\",\"\\\\1\",evidence$Protein.Group.Accessions)\n\ttmp1<-unlist(lapply(evidence$Protein.Descriptions, function(x) substr(x,1,gregexpr(\" - \\\\[\",x)[[1]][1]-1)))\n\n\tevidence$Protein.IDs<-paste(sub(\"^(.*) OS=.*\",\"\\\\1\",tmp1),\" [\",sub(\".* GN=([^ ]*).*$\",\"\\\\1\",tmp1),\" ...]\",sep=\"\")\n\tevidence$Protein.IDs<-paste(evidence$Protein.IDs,\" [\",tmp,\" ...]\",sep=\"\")\n\tevidence$Protein.Group.Accessions<-evidence$Protein.IDs\t# Protein grouping can now take place because the Protein.Group.Accessions value will be the same for groups with the same leading protein\n\t#M+H% calculation (goes to a different data frame, we bind it in the very end with the result data frame)\n\t#For all replicates, \"Spectrum.File\" not pivoted\n\tevidence$Quan.Channel<-factor(evidence$Quan.Channel)\n\tsubtotals_MH<-ddply(evidence,c(\"Protein.Group.Accessions\"),function(x) data.frame(Light=length(which(!grepl(\"Label:\",x$Modifications))),Medium=length(which(grepl(\"Label:2H\\\\(4\\\\)\\\\)\",x)|grepl(\"Label:13C\\\\(6\\\\)\\\\)\",x$Modifications))),Heavy=length(which(grepl(\"Label:13C\\\\(6\\\\)15N\\\\(2\\\\)\",x)|grepl(\"Label:13C\\\\(6\\\\)15N\\\\(4\\\\)\",x$Modifications)))))\n\tsubtotals_MH$MH_percentage<-apply(subtotals_MH,1,function(x){\n\t\t\t\t\t\tLMH<-as.numeric(x[-1])\n\t\t\t\t\t\tif(LMH[1]==0){\n\t\t\t\t\t\t\treturn(100)\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn(100*sum(LMH[-1])/sum(LMH))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t)\n      colnames(subtotals_MH)[1]<-\"Protein.IDs\"\n\n\n\t###\n\tevidence<-evidence[evidence$Quan.Info==\"Unique\" & evidence$Quan.Usage==\"Used\",]\n\t\n\t#filter out peptides where medium and heavy intensity are identical (Heavy.Medium==1) & (X..Missing.Channels==2) & (Quan.Channel==\"Light\"), meaning only the light peak was found\n\tevidence[is.na(evidence$Heavy.Medium),c(\"Heavy.Medium\")]<-0\n\tevidence[is.na(evidence$X..Missing.Channels),c(\"X..Missing.Channels\")]<-0\n\tevidence<-evidence[evidence$Heavy.Medium!=1 & evidence$X..Missing.Channels!=2,]\n\tevidence[evidence$Heavy.Medium==0,c(\"Heavy.Medium\")]<-NA\t#restore back to previous format, change was just for the above condition to work (with NAs it doesn't)\n\n\tLMH<-getLMH(evidence)\n\tn_MH_Proteins<-nrow(LMH[rowSums(LMH[,c(\"Medium\",\"Heavy\")],na.rm=T)>0,]) #Sum of M and H peptides > 0\n\tn_Peptides<-nrow(as.data.frame(tapply(evidence$Sequence,list(Acc=evidence$Sequence),length)))\n\t\n\tif(filterL){\n\t\tevidence<-evidence[evidence$Quan.Channel!=\"Light\",]\n\t\tLMH2<-getLMH(evidence)\n\t\tn_MH_Peptides<-nrow(as.data.frame(tapply(evidence$Sequence,list(Acc=evidence$Sequence),length)))\n\t\tprint(paste(\"Before L peptide filtering (proteins, peptides): \",nrow(LMH),\", \",n_Peptides,\". After: \",nrow(LMH2),\", \",n_MH_Peptides,\".\",sep=\"\"))\n\t\tLMH<-LMH2\n\t\tn_Peptides<-n_MH_Peptides\n\t}\n\tprint(paste(\"Subtotals input (proteins, peptides): \",nrow(LMH),\", \",n_Peptides,\".\",sep=\"\"))\n\t#tmp<-as.data.frame(tapply(evidence$Sequence,list(Seq=evidence$Sequence),length))\n\n\tevidence$Spectrum.File<-factor(evidence$Spectrum.File)\n\n\t#Sum Quan channels individually for each raw file\n\t#subtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) c(Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy))))\n\t#WARNING: below line assumes that ratio (or peptide) quantification counts are the same for all SILAC partners (that's why only one column, the Heavy, is considered as the representative, because it makes no difference). This happens when in PD, in the quantification options the \"re-quantify\" (it is called something else) option is selected\n\tsubtotals<-ddply(evidence,c(\"Spectrum.File\",\"Protein.Group.Accessions\"),function(x) data.frame(Evidence.IDs=paste(x$id,collapse=\";\"),Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy))))\n\tall_evidence_ids<-ddply(subtotals,c(\"Protein.Group.Accessions\"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=\";\")))\n\tcolnames(all_evidence_ids)<-c(\"Protein.IDs\",\"Evidence.IDs\")\n\n\tmelted_subtotals<-melt(subtotals)\t\n\n\t#write.table(row.names(pgroups),file=\"tmp.txt\",row.names=F,sep=\"\\t\")\n\t#write.table(evidence,file=\"tmp2.txt\",row.names=F,sep=\"\\t\")\n\n\tn_techreps<-length(rep_structure)/length(which(!duplicated(rep_structure)))\n\ti_bioreps<-which(!duplicated(rep_structure))[1:n_techreps]\n\tn_bioreps<-length(i_bioreps)\n\t\n\tmelted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)\n\n\t#WARNING: Here it is assumed that the lexigographic order of raw file names is the order of acquisition (usually true)\n\t\n\trep_desc<-paste(paste(\"b\",rep_structure[1:(length(rep_structure)/2)],sep=\"\"),paste(\"t\",rep(1:n_techreps),sep=\"\"),sep=\"\")\n\tif(!is.na(rep_order)){\n\t\to<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))\n\t\trep_desc<-rep_desc[o]\n\t}\n\n\tlevels(melted_subtotals$Spectrum.File)<-rep_desc\n\n\tpgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.Group.Accessions,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))\n\tcolnames(pgroups)[grep(\"\\\\.Light\",colnames(pgroups))]<-sub(\"(.*)\\\\.Light\",\"Intensity.L.\\\\1\",colnames(pgroups)[grep(\"\\\\.Light\",colnames(pgroups))])\n\tcolnames(pgroups)[grep(\"\\\\.Medium\",colnames(pgroups))]<-sub(\"(.*)\\\\.Medium\",\"Intensity.M.\\\\1\",colnames(pgroups)[grep(\"\\\\.Medium\",colnames(pgroups))])\n\tcolnames(pgroups)[grep(\"\\\\.Heavy\",colnames(pgroups))]<-sub(\"(.*)\\\\.Heavy\",\"Intensity.H.\\\\1\",colnames(pgroups)[grep(\"\\\\.Heavy\",colnames(pgroups))])\n\n\tcolnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))]<-sub(\"(.*)\\\\.n\\\\.Peptides\",\"Ratio.H.M.count.\\\\1\",colnames(pgroups)[grep(\"\\\\.n\\\\.Peptides\",colnames(pgroups))])\n\tpgroups<-pgroups[,!(colnames(pgroups) %in% colnames(pgroups)[grep(\"Intensity\\\\.L\\\\.\",colnames(pgroups))])]\n\tpgroups$Protein.IDs<-row.names(pgroups)\n\n\tif(keepEvidenceIDs)\n\t{\n\t\tpgroups<-merge(pgroups,all_evidence_ids,by=\"Protein.IDs\",all.x=T)\n\t}\n\n\tpgroups$time.point<-time.point\n\t\n\tpgroups<-merge(pgroups,subtotals_MH,by=\"Protein.IDs\",all.x=T)\n\n\tpgroups<-pgroups[pgroups$Protein.IDs!=\" [ ...] [ ...]\",]\n\tprint(paste(\"Quantifiable proteins: \",nrow(pgroups),\" (\",time.point,\")\",sep=\"\"))\n\treturn(pgroups)\n}\n\n\nsetwd(\"E:\\\\GE Work\\\\MaxQuant\\\\MaxQuant DataAnalysis\\\\DataAnalysis\")\n\n#GLOBAL variables\n#duplicateCorrelation_trim<-0.22 # use 0.15 for \"nice\" datasets (not \"too many\" missing values)\nduplicateCorrelation_trim<-0.15\n\nrep_structure<-rep(1:6,each=3)\t# 3 bioreps, 3 injections (techreps) each\n\n\ntime.point<-\"2h\"\nPDdata<-F\noutputFigsPrefix<-\"QuaNCAT-rev_IV_2h_HM\"\nprotein_groups<-read.pgroups_v2(\"QuaNCATrev_IV_2h_proteinGroups.txt\",\"2h\",filterL=T,evidence_fname=\"QuaNCATrev_IV_2h_evidence.txt\")\n#do_generate_Venn3_data_quant_filter_1(protein_groups,time.point,outputFigsPrefix=outputFigsPrefix)\ndo_generate_Venn3_data_quant_filter_2reps(protein_groups,time.point,outputFigsPrefix=outputFigsPrefix)\n\n\ntime.point<-\"4h\"\nPDdata<-F\noutputFigsPrefix<-\"QuaNCAT-rev_IV_4h_HM\"\nprotein_groups<-read.pgroups_v2(\"QuaNCATrev_IV_4h_proteinGroups.txt\",\"4h\",filterL=T,evidence_fname=\"QuaNCATrev_IV_4h_evidence.txt\")\n#do_generate_Venn3_data_quant_filter_1(protein_groups,time.point,outputFigsPrefix=outputFigsPrefix)\ndo_generate_Venn3_data_quant_filter_2reps(protein_groups,time.point,outputFigsPrefix=outputFigsPrefix)\n\n#time.point<-\"2h\"\n#PDdata<-F\n#outputFigsPrefix<-\"QuaNCAT-rev_IV_2h_wo_re-quant_HM\"\n#protein_groups<-read.pgroups_v2(\"QuaNCATrev_IV_2h_wo_re-quant_proteinGroups.txt\",\"2h\",filterL=T,evidence_fname=\"QuaNCATrev_IV_2h_wo_re-quant_evidence.txt\")\n\n\n#PD\n# grouping: Perform proteins subtotals (whether it is counting peptides or suming peptides intensities) by grouping\n# peptides in the psms table whenever the leading Protein (first protein ID in Protein.Group.Accessions values) is the same\ngrouping<-T\n\n#PD\nPDdata<-T\ntime.point<-\"2h\"\noutputFigsPrefix<-\"QuaNCAT-rev_IV_2h_PD\"\nevidence_fname<-\"QuanCAT v3 IV 2h_psms_PD.txt\"\ngrouping = T;\nif(grouping){\n\tprotein_groups<-read.pgroups_v2_PD_doGroupIDs(\"QuanCAT v3 IV 2h_proteingroups_PD.txt\",evidence_fname,time.point,rep_structure,keepEvidenceIDs=T)\n}else{\n\tprotein_groups<-read.pgroups_v2_PD(\"QuanCAT v3 IV 2h_proteingroups_PD.txt\",evidence_fname,time.point,rep_structure,keepEvidenceIDs=T)\n}\nwrite.table(protein_groups,file=paste(outputFigsPrefix,\"_proteinGroupsDF.txt\",sep=\"\"),row.names=F,sep=\"\\t\")\ndo_generate_Venn3_data_quant_filter_2reps_PD(protein_groups,time.point,evidence_fname,rep_structure,outputFigsPrefix=outputFigsPrefix,grouping=grouping)\n\n#PD\nPDdata<-T\ntime.point<-\"4h\"\noutputFigsPrefix<-\"test\"\n#evidence_fname<-\"QuanCAT v3 IV 4h_psms_PD.txt\"\nevidence_fname<-\"quancat_2h_PD_psms.txt\"\nif(grouping){\n\tprotein_groups<-read.pgroups_v2_PD_doGroupIDs(\"dummy.txt\",evidence_fname,time.point,rep_structure,keepEvidenceIDs=T,rep_order=c(2,1,3))\n}else{\n\tprotein_groups<-read.pgroups_v2_PD(\"dummy.txt\",evidence_fname,time.point,rep_structure,keepEvidenceIDs=T,rep_order=c(2,1,3))\n}\nwrite.table(protein_groups,file=paste(outputFigsPrefix,\"_proteinGroupsDF.txt\",sep=\"\"),row.names=F,sep=\"\\t\")\ndo_generate_Venn3_data_quant_filter_2reps_PD(protein_groups,time.point,evidence_fname,rep_structure,rep_order=c(2,1,3),outputFigsPrefix=outputFigsPrefix,grouping=grouping)\n\n\n\nexpdesign<-data.frame(rbind(cbind(paste(sub(\"Intensity\\\\.\",\"\",sort(colnames(protein_groups)[grep(\"Intensity.M.b\",colnames(protein_groups))]))),\"CONTROL\"),cbind(paste(sub(\"Intensity\\\\.\",\"\",sort(colnames(protein_groups)[grep(\"Intensity.H.b\",colnames(protein_groups))]))),\"STIMULATED\")))\ncolnames(expdesign)<-c(\"Sample\",\"Category\")\nwrite.table(expdesign,file=\"curr_exp_design.txt\",row.names =F,quote=F,sep = \"\\t\")\nexp_design_fname<-\"curr_exp_design.txt\"\n\n#results<-do_analyse_all_relaxed_v2(protein_groups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=outputFigsPrefix)\nresults<-do_analyse_all_2reps_v2(protein_groups,time.point,exp_design_fname,rep_structure,exportFormat=\"pdf\",outputFigsPrefix=outputFigsPrefix)\n\n\n# VALIDATION HELP\n# For MaxQuant only, for PD this can be done much better through its GUI\ngetValidationData<-function(pgroups_fname,diffexp_fname,evidence_fname,output_fname){\n\tdiffexp<-read.table(diffexp_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\tprotein_groups<-read.table(pgroups_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\t\n\tcolnames(diffexp)<-gsub(\"^X.\",\"\",colnames(diffexp))\n\tcolnames(diffexp)<-gsub(\".$\",\"\",colnames(diffexp))\n\n\tprotein_groups$Protein.IDs<-paste(sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.names),\" [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Gene.names),\" ...] [\",sub(\"^([^;]*).*\",\"\\\\1\",protein_groups$Protein.IDs),\" ...]\",sep=\"\")\n\tprotein_groups$Protein.IDs<-gsub(\"\\\"\",\"\",protein_groups$Protein.IDs)\n\tdiffexp$Protein.IDs<-gsub(\"\\\"\",\"\",diffexp$Protein.IDs)\n\tprotein_groups<-protein_groups[protein_groups$Protein.IDs %in% diffexp$Protein.IDs,]\n\tdiffexp_evidence<-as.data.frame(do.call(rbind,apply(protein_groups,1,function(x) cbind(x[\"Protein.IDs\"],unlist(strsplit(x[\"Evidence.IDs\"],\";\"))))),stringsAsFactors=F)\n\tcolnames(diffexp_evidence)<-c(\"Protein.IDs\",\"Evidence.ID\")\n\tdiffexp_evidence$Protein.IDs<-factor(diffexp_evidence$Protein.IDs)\n\tdiffexp_evidence$Evidence.ID<-as.numeric(diffexp_evidence$Evidence.ID)\n\tevidence<-evidence[,c(\"id\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error..ppm.\",\"K.Count\",\"R.Count\")]\n\tcolnames(evidence)<-c(\"Evidence.ID\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error.ppm.\",\"K.Count\",\"R.Count\")\n\tdiffexp_evidence<-merge(diffexp_evidence,diffexp,by=\"Protein.IDs\",all.x=T)\n\tdiffexp_evidence<-merge(diffexp_evidence,evidence,by=\"Evidence.ID\",all.x=T)\n\twrite.table(diffexp_evidence,file=output_fname,sep=\"\\t\",row.names=F)\n}\n\n#getValidationData(pgroups_fname=\"QuaNCATrev_IV_4h_proteinGroups.txt\",\n#diffexp_fname=\"QuaNCAT-rev_IV_4h_HM-all-2reps_diffexp_4h.txt\",\n#evidence_fname=\"QuaNCATrev_IV_4h_evidence.txt\",\n#output_fname=\"QuaNCATrev_IV_4h_HM-all-2reps_diffexpevidence.txt\")\n\ngetValidationData(pgroups_fname=\"QuaNCATrev_IV_2h_wo_re-quant_proteinGroups.txt\",\ndiffexp_fname=\"QuaNCAT-rev_IV_2h_wo_re-quant_HM-all-2reps_diffexp_2h.txt\",\nevidence_fname=\"QuaNCATrev_IV_2h_wo_re-quant_evidence.txt\",\noutput_fname=\"QuaNCATrev_IV_2h_wo_re-quant_HM-2reps_diffexpevidence.txt\")\n\n# Again, for MaxQuant only\ngetProteinPeptideData_2reps_filter<-function(pgroups_fname,evidence_fname,output_fname,time.point, filterL=T,linkLimmaout=F,limma_outfname=\"\"){\n\tprotein_groups<-read.pgroups_v2(pgroups_fname,time.point,filterL=filterL,evidence_fname=evidence_fname,keepEvidenceIDs=T)\n\tprotein_groups<-pgroups_filter_2reps_v2(protein_groups[protein_groups$time.point == time.point,])\n\n\tevidence<-read.table(evidence_fname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\t\n\tpeptide_evidence<-as.data.frame(do.call(rbind,apply(protein_groups,1,function(x) cbind(x[\"Protein.IDs\"],unlist(strsplit(x[\"Evidence.IDs\"],\";\"))))),stringsAsFactors=F)\n\tcolnames(peptide_evidence)<-c(\"Protein.IDs\",\"Evidence.ID\")\n\tpeptide_evidence$Protein.IDs<-factor(peptide_evidence$Protein.IDs)\n\tpeptide_evidence$Evidence.ID<-as.numeric(peptide_evidence$Evidence.ID)\n\tevidence<-evidence[,c(\"id\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error..ppm.\",\"K.Count\",\"R.Count\",\"Protein.group.IDs\")]\n\tcolnames(evidence)<-c(\"Evidence.ID\",\"Sequence\",\"Labeling.State\",\"Raw.file\",\"MS.MS.Scan.Number\",\"m.z\",\"Charge\",\"Mass.Error.ppm.\",\"K.Count\",\"R.Count\",\"Protein.group.IDs\")\n\tpeptide_evidence<-merge(peptide_evidence,protein_groups[,!names(protein_groups) %in% c(\"Evidence.IDs\")],by=\"Protein.IDs\",all.x=T)\n\tpeptide_evidence<-merge(peptide_evidence,evidence,by=\"Evidence.ID\",all.x=T)\n\tif(linkLimmaout){\n\t\tlimmaout<-read.table(limma_outfname, header = T, sep = \"\\t\",quote='',stringsAsFactors=F)\n\t\tpeptide_evidence<-merge(peptide_evidence,limmaout,by=\"Protein.IDs\",all.x=T)\n\t}\n\twrite.table(peptide_evidence,file=output_fname,sep=\"\\t\",row.names=F)\n}\n\ngetProteinPeptideData_2reps_filter(\n\"QuaNCATrev_IV_2h_proteinGroups.txt\",\n\"QuaNCATrev_IV_2h_evidence.txt\",\n\"QuaNCATrev_IV_2h_HM-all-2reps_evidence.txt\",\n\"2h\",\nfilterL=T,\nlinkLimmaout=T,\nlimma_outfname=\"QuaNCAT-rev_IV_2h_HM-all-2reps_limmaout_2h.txt\")\n\ngetProteinPeptideData_2reps_filter(\n\"QuaNCATrev_IV_4h_proteinGroups.txt\",\n\"QuaNCATrev_IV_4h_evidence.txt\",\n\"QuaNCATrev_IV_4h_HM-all-2reps_evidence.txt\",\n\"4h\",\nfilterL=T,\nlinkLimmaout=T,\nlimma_outfname=\"QuaNCAT-rev_IV_4h_HM-all-2reps_limmaout_4h.txt\")\n\ngetProteinPeptideData_2reps_filter(\n\"QuaNCATrev_IV_2h_proteinGroups.txt\",\n\"QuaNCATrev_IV_2h_evidence.txt\",\n\"QuaNCATrev_IV_2h_all-2reps_evidence.txt\",\n\"2h\",\nfilterL=F)\n\ngetProteinPeptideData_2reps_filter(\n\"QuaNCATrev_IV_4h_proteinGroups.txt\",\n\"QuaNCATrev_IV_4h_evidence.txt\",\n\"QuaNCATrev_IV_4h_all-2reps_evidence.txt\",\n\"4h\",\nfilterL=F)\n\n\n\n#DEBUG ABOVE\npgroups_fname<-\"QuaNCATrev_IV_2h_proteinGroups.txt\"\nevidence_fname<-\"QuaNCATrev_IV_2h_evidence.txt\"\noutput_fname<-\"QuaNCATrev_IV_2h_HM-all-2reps_evidence.txt\"\ntime.point<-\"2h\"\nlimma_outfname<-\"QuaNCAT-rev_IV_2h_HM-all-2reps_limmaout_2h.txt\"\n\n\n",
    "created" : 1399640521633.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "8|2|10|29|\n25|1|33|0|\n37|1|45|0|\n50|1|58|0|\n61|110|67|0|\n70|1|92|0|\n108|70|142|0|\n144|21|151|0|\n157|48|185|0|\n189|102|327|0|\n498|111|553|0|\n951|128|1052|0|\n",
    "hash" : "3374378813",
    "id" : "8CBCE1F6",
    "lastKnownWriteTime" : 1399644602,
    "path" : "~/ProteoSign/dev/msdiffexp/v2/limma8.R",
    "project_path" : "limma8.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}