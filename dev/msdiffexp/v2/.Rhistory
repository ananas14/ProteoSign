})
}else{
#Calculate peptide intesity per label and per replicate
levellog("Calculating peptide intesity per label and per replicate ...");
#First, We have to remove the labels from the modifications column, because we have to pivot on modifications but not on labels
modcol<-evidence$Modifications
for(i in 1:length(conditions.labels)){
for(mod_i in conditions.labels.Modifications[[i]]){
if(mod_i != ""){
modcol<-gsub(paste("[A-Z]+[0-9]+\\(",mod_i,"[; ]*",sep=""),"",modcol)
}
}
}
modcol<-gsub("^[ ]+","",modcol)
modcol<-gsub(";[ ]+$","",modcol)
evidence[,"Modifications.only"]<-modcol
subtotals2<-ddply(evidence,c("Spectrum.File","Unique.Sequence.ID","Modifications.only"),function(x){
cond_sums<-c()
for(cond_i in conditions.labels){
cond_sums<-cbind(cond_sums, sum(x[,cond_i],na.rm=T))
}
cond_counts<-sum(!is.na(x[,conditions.labels[1]])) # It doesn't matter which label is used for counting. This is the ratio counts, and since PD replaces missing signlas with the minimum intensity, there will always be a ratio, and the number of ratios will be equal to the number of records here. Unwanted ratios, such as those that are equal to 1 and should not be considered/counted are filtered above, at the peptide-filtering stage if chosen by the user (recommended)
ret<-data.frame(cbind(cond_sums,cond_counts))
colnames(ret)<-c(conditions.labels,"Ratio.counts")
ret$Evidence.IDs<-paste(x$id,collapse=";")
ret$Sequence<-toupper(x$Sequence[1])
ret$Protein.IDs<-x$Protein.IDs[1]
return(ret)
#data.frame(Evidence.IDs=paste(x$id,collapse=";"),Light=sum(x$Light,na.rm=T),Medium=sum(x$Medium,na.rm=T),Heavy=sum(x$Heavy,na.rm=T),n.Peptides=sum(!is.na(x$Heavy)))
})
}
#write.table(file="tmp.txt",subtotals2,row.names=F,sep="\t")
levellog("Re-arranging data and assigning column names ...");
#Re-arrange data and assign column names
if(ProteinQuantitation){
melted_subtotals<-melt(subtotals2)
}else{
melted_subtotals<-melt(subtotals2,id.vars=c("Spectrum.File", "Modifications.only", "Evidence.IDs", "Sequence", "Protein.IDs", "Unique.Sequence.ID"))
}
n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions
n_techreps<-length(rep_structure)/(n_bioreps*nConditions)
i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]
melted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)
rep_desc<-paste(paste("b",rep_structure[1:(length(rep_structure)/nConditions)],sep=""),paste("t",rep(1:n_techreps),sep=""),sep="")
if(!is.na(rep_order)){
o<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))
rep_desc<-rep_desc[o]
}
# For the label-free case: multiplex conditions so we have the same data format downstream, i.e. as with labelled experiments
if(LabelFree){
tmp_rep_desc<-c()
for(i in 1:nConditions){
tmp_rep_desc[[i]]<-paste("c",i,rep_desc,sep="")
levels(melted_subtotals$Spectrum.File)[which(levels(melted_subtotals$Spectrum.File) %in% paste(conditions.labels.Modifications[[i]],".raw",sep=""))]<-tmp_rep_desc[[i]]
}
rep_desc<-unlist(tmp_rep_desc)
melted_subtotals$brtr<-NA
biorep_techrep<-regmatches(levels(melted_subtotals$Spectrum.File), regexpr("b.*", levels(melted_subtotals$Spectrum.File)))
for(i in 1:length(levels(melted_subtotals$Spectrum.File))){
lvl_i<-levels(melted_subtotals$Spectrum.File)[i]
brtr<-biorep_techrep[i]
melted_subtotals[melted_subtotals$Spectrum.File == lvl_i,"brtr"]<-brtr
}
melted_subtotals$brtr<-factor(melted_subtotals$brtr)
}else{
levels(melted_subtotals$Spectrum.File)<-rep_desc
}
if(ProteinQuantitation){
if(LabelFree){
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$brtr,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}else{
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}
}else{
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Peptide.IDs=paste(melted_subtotals$Sequence," [",melted_subtotals$Modifications.only,"]",sep=""),RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}
for(cond_i in conditions.labels){
colnames(pgroups)[grep(paste("\\.",cond_i,"$",sep=""),colnames(pgroups))]<-sub(paste("(.*)\\.",cond_i,sep=""),paste("Intensity.",cond_i,".\\1",sep=""),colnames(pgroups)[grep(paste("\\.",cond_i,"$",sep=""),colnames(pgroups))])
}
pgroups[,paste(quantitated_items_lbl,".IDs",sep="")]<-row.names(pgroups)
#Collect peptide records for each protein
if(keepEvidenceIDs && ProteinQuantitation)
{
all_evidence_ids<-ddply(subtotals2,c("Protein.IDs"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=";")))
pgroups<-merge(pgroups,all_evidence_ids,by=paste(quantitated_items_lbl,".IDs",sep=""),all.x=T)
}
if(ProteinQuantitation){
pgroups<-pgroups[,!(colnames(pgroups) %in% c("Protein.Descriptions"))]
}
pgroups$time.point<-time.point
if(!ProteinQuantitation){
subtotals2$Peptide.IDs<-paste(subtotals2$Sequence," [",subtotals2$Modifications.only,"]",sep="")
pgroups<-merge(pgroups,subtotals2[!duplicated(subtotals2$Peptide.IDs),c("Peptide.IDs","Protein.IDs")],by="Peptide.IDs",all.x=T)
# Remove peptides that we don't want to quantify (conditions.Mod is not empty means the user wants to do quantification on peptides with certain modifications only)
if(length(conditions.Mods)>0){
for(i in 1:length(conditions.Mods)){
for(mod_i_mods in conditions.Mods.Modifications[[i]]){
pgroups<-pgroups[grepl(mod_i_mods,pgroups$Peptide.IDs),]
}
}
}
#write.table(file="tmp.txt",merge(pgroups,subtotals2[!duplicated(subtotals2$Peptide.IDs),c("Peptide.IDs","Protein.IDs")],by="Peptide.IDs",all.x=T),row.names=F,sep="\t")
}
pgroups<-merge(pgroups,subtotals,by="Protein.IDs",all.x=T)
#If enabled, do filter out proteins based on percentage labeling for the desired label
if(ProteinQuantitation && filterL && !filterL_lvl){
levellog("Filter out proteins based on percentage labeling for the desited label ...");
fl<-paste(filterL_lbl,"p",sep="")
pgroups<-pgroups[pgroups[,c(fl)]<100,]
}
if(ProteinQuantitation){
cat(paste("read.pgroups_v2_PD: Quantifiable proteins: ",nrow(pgroups)," (",time.point,")\n",sep=""))
}else{
cat(paste("read.pgroups_v2_PD: Quantifiable peptides: ",nrow(pgroups)," (",time.point,")\n",sep=""))
}
row.names(pgroups)<-pgroups[,paste(quantitated_items_lbl,".IDs",sep="")]
levellog("",change=-1)
return(pgroups)
}
rep_structure
protein_groups<<-read.pgroups_v2_PD(pgroups_fname,evidence_fname,time.point,rep_structure,keepEvidenceIDs=T,rep_order=rep_order)
str(protein_groups)
expdesign
working_pgroups<-pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,])
pgroups<-protein_groups
working_pgroups<-pgroups_filter_2reps_v2(pgroups[pgroups$time.point == time.point,])
str(working_pgroups)
working_pgroups<-prepare_working_pgroups(working_pgroups)
str(working_pgroups)
getwd()
levellog("",change=1)
levellog("Preparing limma input data frame ...")
# Read the sample key
# Assigns sample names (from the data file) to groups
# Sample order must be the same as the main data file, but excludes technical
# replicates as we will aggregate into one value per sample.
sample.key <- read.delim(exp_design_fname, header=TRUE,row.names=1,colClasses="character")
sample.key$Category <- factor(sample.key$Category, levels=unique(sample.key$Category))
# Extract protein/peptide quantitation columns only from quantitation input file
# The quantitation data is in columns 10 to 90.
#prot.intensities <- quantitation[,10:90]
prot.intensities <- working_pgroups
# Extract the protein names/peptide sequences (imported from the data file) into a
# separate list for future reference
prot.names <- rownames(prot.intensities)
# Take log2 of intensities
log.intensities  <- log2(prot.intensities)
setwd(limma_output)
levellog("Saving limma input frame ...")
write.table(working_pgroups,file=paste(outputFigsPrefix,"_limma-input_",quantitated_items_lbl,"Groups.txt",sep=""),sep="\t",row.names = T, col.names=NA)
if(exportFormat == "pdf"){
pdf(file=paste(outputFigsPrefix,"_limma-graphs_",time.point,".pdf",sep=""),width=10, height=7, family = "Helvetica", pointsize=8)
}
# Box plot before normalisation
boxplot(log.intensities)
title(main="Intensities Before Normalisation")
# Perform quantile normalisation
levellog("Performing quantile normalisation ...")
norm.intensities <- normalizeBetweenArrays(data.matrix(log.intensities), method="quantile");
# Box plot after normalisation
boxplot(norm.intensities)
title(main="Intensities After Normalisation")
norm.median.intensities<-as.data.frame(t(as.matrix(norm.intensities)))
# Assign row names to our aggregated intensities from the sample key
row.names(norm.median.intensities) <- row.names(sample.key)
# Setup design matrix
# This specifies the design of the experiment for limma, replicating
# the info in the sample key, but representing it in a matrix format
levellog("Constructing the design matrix ...")
design <- model.matrix(~0 + factor(sample.key$Category))
colnames(design) <- levels(sample.key$Category)
write.table(design,file=paste(outputFigsPrefix,"_limma-design-matrix_",quantitated_items_lbl,"Groups.txt",sep=""),sep="\t",row.names = T, col.names=NA)
write.table(rep_structure,file=paste(outputFigsPrefix,"_limma-blocking-variable_",quantitated_items_lbl,"Groups.txt",sep=""),sep="\t",row.names = T, col.names=NA)
fit<-""
n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions
n_techreps<-length(rep_structure)/(n_bioreps*nConditions)
levellog("Fitting the model ...")
if(n_bioreps > 1 & n_techreps > 1){
# technical replication specification
corfit <- duplicateCorrelation(t(norm.median.intensities), design=design, block = rep_structure, trim = duplicateCorrelation_trim)
# Fit the limma model to the data
# Pass the protein names/peptide sequences to limma as the genes option
fit <- lmFit(t(norm.median.intensities), design, genes=prot.names, block = rep_structure, cor = corfit$consensus)
}else{
fit <- lmFit(t(norm.median.intensities), design, genes=prot.names)
}
# Setup contrast matrix
# The contrast matrix specifies what comparisons we want to make between groups.
# We pass the design matrix as the levels option to the makeContrasts function.
levellog("Constructing the contrast matrix ...")
ratio_combs<-combinations(nConditions,2,1:nConditions)
contrasts<-c()
for(i in 1:nrow(ratio_combs)){
contrasts<-c(contrasts,paste(conditions.labels[ratio_combs[i,2]],"-",conditions.labels[ratio_combs[i,1]],sep=""))
}
contrasts <- makeContrasts(contrasts=contrasts, levels=design)
write.table(contrasts,file=paste(outputFigsPrefix,"_limma-contrasts-matrix_",quantitated_items_lbl,"Groups.txt",sep=""),sep="\t",row.names = T, col.names=NA)
# Apply contrast matrix and do empirical bayes analysis to get p-values etc.
levellog("Performing hypothesis testing ...")
fit2 <- contrasts.fit(fit, contrasts)
fit2 <- eBayes(fit2)
# Make volcano plot
#volcanoplot(fit2, highlight="20")
#title(main="Log odds vs fold change STIMULATED-CTRL", sub="Top 20 most significant proteins highlighted")
# Plot a Histogram of co-efficients (log2 ratio)
for(i in 1:nrow(ratio_combs)){
ratio_i_str<-paste(conditions.labels[ratio_combs[i,2]],"/",conditions.labels[ratio_combs[i,1]],sep="")
hist(fit2$coefficients[,i],main=paste("Log2 Fold Change ",ratio_i_str,sep=""), xlab="Log2 Fold Change", breaks=50 )
}
if(exportFormat == "emf"){
savePlot(filename=paste(outputFigsPrefix,"_limma-graphs_",time.point,"_hist.emf",sep=""),type="emf")
}
# Do an MA Plot (mean of log2 intensities vs log2 ratio)
# Important to inspect the MA plot to ensures that the ratio does not depend on
# the intensity of the protein/peptide. This shouldn't happen if the data was normalised
# successfully, and should be unusual in SILAC / label-free experiments.
#for(i in 1:nrow(ratio_combs)){
#  plotMA(fit2)
# Add a line at y=0 to the MA plot. The clouds of points should be centred around y=0
# if most proteins/peptides are unchanges and normalisation worked well.
#  abline(h=0)
#  if(exportFormat == "emf"){
#    savePlot(filename=paste(outputFigsPrefix,"_limma-graphs_",time.point,"_MA.emf",sep=""),type="emf")
#  }
#}
dev.off()
# Output analysis details to file
# asjust="BH" means adjust the calculated p-values for multiple testing using
# the Benjamini Hochberg method (FDR)
levellog("Saving analysis results to file ...")
write.fit(fit2, file=paste(outputFigsPrefix,"_condition-i_vs_condition-j_",time.point,".txt",sep=""), adjust="BH")
norm.median.intensities<<-norm.median.intensities #for debugging purposes
levellog("Generating analysis plots ...")
getwd()
setwd("..")
protein_groups<<-read.pgroups_v2_PD(pgroups_fname,evidence_fname,time.point,rep_structure,keepEvidenceIDs=T,rep_order=rep_order)
do_generate_Venn3_data_quant_filter_2reps_PD(protein_groups,time.point,evidence_fname,rep_structure,outputFigsPrefix=outputFigsPrefix,rep_order=rep_order)
# Like the (see) above function, but without protein grouping.
id_Venn3_pgroups_PD<-function(fname,evidence_fname,time.point,rep_structure,filterL=F,rep_order=NA){
evidence<-read.table(evidence_fname, header = T, sep = "\t",quote='',stringsAsFactors=F,comment.char = "")
#Generate Evidence ID
evidence$id<-1:(nrow(evidence))
allproteins<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions),length))
allproteins<-data.frame(Protein.IDs=names(allproteins[[1]]),stringsAsFactors=F)
tmpdf<-evidence[,c("Protein.Group.Accessions","Protein.Descriptions")]
colnames(tmpdf)<-c("Protein.IDs","Protein.Descriptions")
tmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]
allproteins<-merge(allproteins,tmpdf,by="Protein.IDs",all.x=T)
tmp<-sub("^([^;]*).*","\\1",allproteins$Protein.IDs)
tmp1<-unlist(lapply(allproteins$Protein.Descriptions, function(x) substr(x,1,gregexpr(" - \\[",x)[[1]][1]-1)))
allproteins$Protein.Group.Accessions<-allproteins$Protein.IDs   #keep old IDs
allproteins$Protein.IDs<-paste(sub("^(.*) OS=.*","\\1",tmp1)," [",sub(".* GN=([^ ]*).*$","\\1",tmp1)," ...]",sep="")
allproteins$Protein.IDs<-paste(allproteins$Protein.IDs," [",tmp," ...]",sep="")
allproteins<-allproteins[!duplicated(allproteins$Protein.IDs),]
#cat(paste("Identified proteins: ",nrow(allproteins)," (",time.point,")",sep=""))
evidence<-merge(evidence,allproteins,by="Protein.Group.Accessions",all.x=T)
evidence$Spectrum.File<-factor(evidence$Spectrum.File)
if(ProteinQuantitation){
#Count unique peptide sequences per protein and replicate
subtotals2<-ddply(evidence,c("Spectrum.File","Protein.IDs"),function(x){
ids<-paste(x$id,collapse=";")
ret<-data.frame(cbind(ids))
colnames(ret)<-c("Evidence.IDs")
nUniqueSequences<-length(unique(x$Unique.Sequence.ID))
ret$uniqueSequences<-nUniqueSequences
return(ret)
})
all_evidence_ids<-ddply(subtotals2,c("Protein.IDs"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=";")))
}else{
#Count unique peptide sequences per replicate
#First, We have to remove the labels from the modifications column, because we have to pivot on modifications but not on labels
modcol<-evidence$Modifications
for(i in 1:length(conditions.labels)){
for(mod_i in conditions.labels.Modifications[[i]]){
if(mod_i != ""){
modcol<-gsub(paste("[A-Z]+[0-9]+\\(",mod_i,"[; ]*",sep=""),"",modcol)
}
}
}
modcol<-gsub("^[ ]+","",modcol)
modcol<-gsub(";[ ]+$","",modcol)
evidence[,"Modifications.only"]<-modcol
subtotals2<-ddply(evidence,c("Spectrum.File","Unique.Sequence.ID","Modifications.only"),function(x){
ids<-paste(x$id,collapse=";")
ret<-data.frame(cbind(ids))
colnames(ret)<-c("Evidence.IDs")
ret$Sequence<-toupper(x$Sequence[1])
return(ret)
})
}
#Re-arrange data and assign column names
if(ProteinQuantitation){
melted_subtotals<-melt(subtotals2)
}else{
melted_subtotals<-melt(subtotals2,id.vars=c("Spectrum.File", "Sequence", "Modifications.only", "Evidence.IDs"))
}
#write.table(tmp,file="tmp.txt",row.names=F,sep="\t")
#write.table(evidence,file="tmp2.txt",row.names=F,sep="\t")
n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions
n_techreps<-length(rep_structure)/(n_bioreps*nConditions)
i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]
melted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)
rep_desc<-paste(paste("b",rep_structure[1:(length(rep_structure)/nConditions)],sep=""),paste("t",rep(1:n_techreps),sep=""),sep="")
if(!is.na(rep_order)){
o<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))
rep_desc<-rep_desc[o]
}
if(LabelFree){
tmp_rep_desc<-c()
for(i in 1:nConditions){
tmp_rep_desc[[i]]<-paste("c",i,rep_desc,sep="")
levels(melted_subtotals$Spectrum.File)[which(levels(melted_subtotals$Spectrum.File) %in% paste(conditions.labels.Modifications[[i]],".raw",sep=""))]<-tmp_rep_desc[[i]]
}
rep_desc<-unlist(tmp_rep_desc)
melted_subtotals$brtr<-NA
biorep_techrep<-regmatches(levels(melted_subtotals$Spectrum.File), regexpr("b.*", levels(melted_subtotals$Spectrum.File)))
for(i in 1:length(levels(melted_subtotals$Spectrum.File))){
lvl_i<-levels(melted_subtotals$Spectrum.File)[i]
brtr<-biorep_techrep[i]
melted_subtotals[melted_subtotals$Spectrum.File == lvl_i,"brtr"]<-brtr
}
melted_subtotals$brtr<-factor(melted_subtotals$brtr)
}else{
levels(melted_subtotals$Spectrum.File)<-rep_desc
}
if(ProteinQuantitation){
if(LabelFree){
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$brtr,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}else{
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}
}else{
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Peptide.IDs=paste(melted_subtotals$Sequence," [",melted_subtotals$Modifications.only,"]",sep=""),RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) length(x)))
pgroups[is.na(pgroups)]<-0
}
pgroups[,paste(quantitated_items_lbl,".IDs",sep="")]<-row.names(pgroups)
if(keepEvidenceIDs && ProteinQuantitation)
{
pgroups<-merge(pgroups,all_evidence_ids,by="Protein.IDs",all.x=T)
}
# Remove peptides that are not of interest (conditions.Mod is not empty means the user wants peptides with certain modifications only)
if(!ProteinQuantitation && length(conditions.Mods)>0){
for(i in 1:length(conditions.Mods)){
for(mod_i_mods in conditions.Mods.Modifications[[i]]){
pgroups<-pgroups[grepl(mod_i_mods,pgroups$Peptide.IDs),]
}
}
}
if(ProteinQuantitation){
#pgroups<-pgroups[,!(colnames(pgroups) %in% c("Protein.Descriptions"))]
#cat(paste("id_Venn3_pgroups_PD: Identified proteins: ",nrow(pgroups)," (",time.point,")\n",sep=""))
}else{
cat(paste("id_Venn3_pgroups_PD: Peptide modified sequences: ",nrow(pgroups)," (",time.point,")\n",sep=""))
}
row.names(pgroups)<-pgroups[,paste(quantitated_items_lbl,".IDs",sep="")]
venn_data<-c()
for(brep_i in 1:n_bioreps){
if(n_techreps>1){
b_i<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(paste("b",brep_i,sep=""),colnames(pgroups))]],na.rm=T)>0,c(paste(quantitated_items_lbl,".IDs",sep=""))],stringsAsFactors=F)
b_i$rep<-as.character(brep_i)
venn_data<-rbind(venn_data,b_i)
}else{
b_i_col<-colnames(pgroups)[grep(paste("b",brep_i,sep=""),colnames(pgroups))]
b_i<-data.frame(Protein.IDs=pgroups[!is.na(pgroups[,b_i_col]) & pgroups[,b_i_col]>0,c(paste(quantitated_items_lbl,".IDs",sep=""))],stringsAsFactors=F)
b_i$rep<-as.character(brep_i)
venn_data<-rbind(venn_data,b_i)
}
}
colnames(venn_data)[1]<-paste(quantitated_items_lbl,".IDs",sep="")
return(venn_data)
}
protein_groups<<-read.pgroups_v2_PD(pgroups_fname,evidence_fname,time.point,rep_structure,keepEvidenceIDs=T,rep_order=rep_order)
do_generate_Venn3_data_quant_filter_2reps_PD(protein_groups,time.point,evidence_fname,rep_structure,outputFigsPrefix=outputFigsPrefix,rep_order=rep_order)
evidence<-read.table(evidence_fname, header = T, sep = "\t",quote='',stringsAsFactors=F,comment.char = "")
#Generate Evidence ID
evidence$id<-1:(nrow(evidence))
allproteins<-as.data.frame(tapply(evidence$Protein.Group.Accessions,list(Acc=evidence$Protein.Group.Accessions),length))
allproteins<-data.frame(Protein.IDs=names(allproteins[[1]]),stringsAsFactors=F)
tmpdf<-evidence[,c("Protein.Group.Accessions","Protein.Descriptions")]
colnames(tmpdf)<-c("Protein.IDs","Protein.Descriptions")
tmpdf<-tmpdf[!duplicated(tmpdf$Protein.IDs),]
allproteins<-merge(allproteins,tmpdf,by="Protein.IDs",all.x=T)
tmp<-sub("^([^;]*).*","\\1",allproteins$Protein.IDs)
tmp1<-unlist(lapply(allproteins$Protein.Descriptions, function(x) substr(x,1,gregexpr(" - \\[",x)[[1]][1]-1)))
allproteins$Protein.Group.Accessions<-allproteins$Protein.IDs   #keep old IDs
allproteins$Protein.IDs<-paste(sub("^(.*) OS=.*","\\1",tmp1)," [",sub(".* GN=([^ ]*).*$","\\1",tmp1)," ...]",sep="")
allproteins$Protein.IDs<-paste(allproteins$Protein.IDs," [",tmp," ...]",sep="")
allproteins<-allproteins[!duplicated(allproteins$Protein.IDs),]
#cat(paste("Identified proteins: ",nrow(allproteins)," (",time.point,")",sep=""))
evidence<-merge(evidence,allproteins,by="Protein.Group.Accessions",all.x=T)
evidence$Spectrum.File<-factor(evidence$Spectrum.File)
if(ProteinQuantitation){
#Count unique peptide sequences per protein and replicate
subtotals2<-ddply(evidence,c("Spectrum.File","Protein.IDs"),function(x){
ids<-paste(x$id,collapse=";")
ret<-data.frame(cbind(ids))
colnames(ret)<-c("Evidence.IDs")
nUniqueSequences<-length(unique(x$Unique.Sequence.ID))
ret$uniqueSequences<-nUniqueSequences
return(ret)
})
all_evidence_ids<-ddply(subtotals2,c("Protein.IDs"),function(x) data.frame(Evidence.IDs=paste(x$Evidence.IDs,collapse=";")))
}else{
#Count unique peptide sequences per replicate
#First, We have to remove the labels from the modifications column, because we have to pivot on modifications but not on labels
modcol<-evidence$Modifications
for(i in 1:length(conditions.labels)){
for(mod_i in conditions.labels.Modifications[[i]]){
if(mod_i != ""){
modcol<-gsub(paste("[A-Z]+[0-9]+\\(",mod_i,"[; ]*",sep=""),"",modcol)
}
}
}
modcol<-gsub("^[ ]+","",modcol)
modcol<-gsub(";[ ]+$","",modcol)
evidence[,"Modifications.only"]<-modcol
subtotals2<-ddply(evidence,c("Spectrum.File","Unique.Sequence.ID","Modifications.only"),function(x){
ids<-paste(x$id,collapse=";")
ret<-data.frame(cbind(ids))
colnames(ret)<-c("Evidence.IDs")
ret$Sequence<-toupper(x$Sequence[1])
return(ret)
})
}
#Re-arrange data and assign column names
if(ProteinQuantitation){
melted_subtotals<-melt(subtotals2)
}else{
melted_subtotals<-melt(subtotals2,id.vars=c("Spectrum.File", "Sequence", "Modifications.only", "Evidence.IDs"))
}
#write.table(tmp,file="tmp.txt",row.names=F,sep="\t")
#write.table(evidence,file="tmp2.txt",row.names=F,sep="\t")
n_bioreps<-length(which(!duplicated(rep_structure)))/nConditions
n_techreps<-length(rep_structure)/(n_bioreps*nConditions)
i_bioreps<-which(!duplicated(rep_structure))[1:n_bioreps]
melted_subtotals$Spectrum.File<-factor(melted_subtotals$Spectrum.File)
rep_desc<-paste(paste("b",rep_structure[1:(length(rep_structure)/nConditions)],sep=""),paste("t",rep(1:n_techreps),sep=""),sep="")
if(!is.na(rep_order)){
o<-unlist(lapply(rep_order,function(x)((x-1)*n_techreps+1):(((x-1)*n_techreps+1)+n_techreps-1)))
rep_desc<-rep_desc[o]
}
if(LabelFree){
tmp_rep_desc<-c()
for(i in 1:nConditions){
tmp_rep_desc[[i]]<-paste("c",i,rep_desc,sep="")
levels(melted_subtotals$Spectrum.File)[which(levels(melted_subtotals$Spectrum.File) %in% paste(conditions.labels.Modifications[[i]],".raw",sep=""))]<-tmp_rep_desc[[i]]
}
rep_desc<-unlist(tmp_rep_desc)
melted_subtotals$brtr<-NA
biorep_techrep<-regmatches(levels(melted_subtotals$Spectrum.File), regexpr("b.*", levels(melted_subtotals$Spectrum.File)))
for(i in 1:length(levels(melted_subtotals$Spectrum.File))){
lvl_i<-levels(melted_subtotals$Spectrum.File)[i]
brtr<-biorep_techrep[i]
melted_subtotals[melted_subtotals$Spectrum.File == lvl_i,"brtr"]<-brtr
}
melted_subtotals$brtr<-factor(melted_subtotals$brtr)
}else{
levels(melted_subtotals$Spectrum.File)<-rep_desc
}
if(ProteinQuantitation){
if(LabelFree){
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$brtr,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}else{
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Protein.IDs=melted_subtotals$Protein.IDs,RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) sum(x,na.rm=T)))
}
}else{
pgroups<-as.data.frame(tapply(melted_subtotals$value,list(Peptide.IDs=paste(melted_subtotals$Sequence," [",melted_subtotals$Modifications.only,"]",sep=""),RawFile=melted_subtotals$Spectrum.File,LMHn=melted_subtotals$variable),function(x) length(x)))
pgroups[is.na(pgroups)]<-0
}
pgroups[,paste(quantitated_items_lbl,".IDs",sep="")]<-row.names(pgroups)
if(keepEvidenceIDs && ProteinQuantitation)
{
pgroups<-merge(pgroups,all_evidence_ids,by="Protein.IDs",all.x=T)
}
# Remove peptides that are not of interest (conditions.Mod is not empty means the user wants peptides with certain modifications only)
if(!ProteinQuantitation && length(conditions.Mods)>0){
for(i in 1:length(conditions.Mods)){
for(mod_i_mods in conditions.Mods.Modifications[[i]]){
pgroups<-pgroups[grepl(mod_i_mods,pgroups$Peptide.IDs),]
}
}
}
if(ProteinQuantitation){
#pgroups<-pgroups[,!(colnames(pgroups) %in% c("Protein.Descriptions"))]
#cat(paste("id_Venn3_pgroups_PD: Identified proteins: ",nrow(pgroups)," (",time.point,")\n",sep=""))
}else{
cat(paste("id_Venn3_pgroups_PD: Peptide modified sequences: ",nrow(pgroups)," (",time.point,")\n",sep=""))
}
row.names(pgroups)<-pgroups[,paste(quantitated_items_lbl,".IDs",sep="")]
venn_data<-c()
str(pgroups)
n_bioreps
for(brep_i in 1:n_bioreps){
if(n_techreps>1){
b_i<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(paste("b",brep_i,sep=""),colnames(pgroups))]],na.rm=T)>0,c(paste(quantitated_items_lbl,".IDs",sep=""))],stringsAsFactors=F)
b_i$rep<-as.character(brep_i)
venn_data<-rbind(venn_data,b_i)
}else{
b_i_col<-colnames(pgroups)[grep(paste("b",brep_i,sep=""),colnames(pgroups))]
b_i<-data.frame(Protein.IDs=pgroups[!is.na(pgroups[,b_i_col]) & pgroups[,b_i_col]>0,c(paste(quantitated_items_lbl,".IDs",sep=""))],stringsAsFactors=F)
b_i$rep<-as.character(brep_i)
venn_data<-rbind(venn_data,b_i)
}
}
colnames(venn_data)[1]<-paste(quantitated_items_lbl,".IDs",sep="")
str(venn_data)
venn_data
brep_i<-1
venn_data<-c()
n_techreps
b_i<-data.frame(Protein.IDs=pgroups[rowSums(pgroups[,colnames(pgroups)[grep(paste("b",brep_i,sep=""),colnames(pgroups))]],na.rm=T)>0,c(paste(quantitated_items_lbl,".IDs",sep=""))],stringsAsFactors=F)
str(b_i)
