return(FALSE)
}
conditions.labels<<-c(conditions.labels, lblname)
j<-length(conditions.labels.Modifications)+1
conditions.labels.Modifications[[j]]<<-lbl.Modifications
nConditions<<-length(conditions.labels)
levellog("", change=-1)
}
removeLabel<-function(lblname){
levellog("", change=1)
lblname_i<-which(grepl(paste("^",lblname,"$",sep=""),conditions.labels))
if(length(lblname_i) != 0){
conditions.labels<<-conditions.labels[-lblname_i]
conditions.labels.Modifications<<-conditions.labels.Modifications[-lblname_i]
}
nConditions<<-length(conditions.labels)
levellog("", change=-1)
}
clearLabels<-function(){
levellog("", change=1)
conditions.labels<<-c()
conditions.labels.Modifications<<-list()
nConditions<<-length(conditions.labels)
levellog("", change=-1)
}
addMod<-function(modname, mod.Modifications){
levellog("", change=1)
modname<-make.names(modname)
mod.Modifications<-gsub("\\(","\\\\(",mod.Modifications)
mod.Modifications<-gsub("\\)","\\\\)",mod.Modifications)
unmod_idx<-which(mod.Modifications == "")
if(length(unmod_idx) > 0){
rest_idx<-which(mod.Modifications[-unmod_idx] != "")
if(length(rest_idx) > 0){
mod.Modifications<-c(mod.Modifications[unmod_idx],paste(mod.Modifications[-unmod_idx],"\\)",sep=""))
}
}else{
mod.Modifications<-paste(mod.Modifications,"\\)",sep="")
}
modname_i<-which(grepl(paste("^",modname,"$",sep=""),conditions.Mods))
if(length(modname_i) != 0){
levellog(paste("addMod: Error adding modification '",modname,"': An existing modification with name '",modname,"' (specification: ",paste(unlist(conditions.Mods.Modifications[modname_i]),collapse=", "),") already exists. Please try a different name.",sep=""), change=-1)
return(FALSE)
}
i<-1
for(mod_i in conditions.Mods.Modifications){
for(mod_i in mod.Modifications){
mod_i_matches<-which(grepl(paste("^",mod_i,"$",sep=""),mod_i))
if(length(mod_i_matches) != 0){
levellog(paste("addMod: Error adding modification '",modname,"': Existing modification with name '",conditions.Mods[i],"' has an identical specification (",mod_i,").",sep=""),change=-1)
return(FALSE)
}
}
i<-i+1
}
conditions.Mods<<-c(conditions.Mods, modname)
j<-length(conditions.Mods.Modifications)+1
conditions.Mods.Modifications[[j]]<<-mod.Modifications
nMods<<-length(conditions.Mods)
levellog("", change=-1)
}
removeMod<-function(modname){
levellog("", change=1)
modname_i<-which(grepl(paste("^",modname,"$",sep=""),conditions.Mods))
if(length(modname_i) != 0){
conditions.Mods<<-conditions.Mods[-modname_i]
conditions.Mods.Modifications<<-conditions.Mods.Modifications[-modname_i]
}
nMods<<-length(conditions.Mods)
levellog("", change=-1)
}
clearMods<-function(){
levellog("", change=1)
conditions.Mods<<-c()
conditions.Mods.Modifications<<-list()
nMods<<-length(conditions.Mods)
levellog("", change=-1)
}
# ======= INITIALIZATION =======
unlabeled_peptide_regex<-"^$"
clearLabels()
clearMods()
paramssetfromGUI<-F
working_directory<-getwd()
limma_output<-"msdiffexp_out"
LabelFree<-F
AllowLabelRename<-F
AllowLS<-F
if (!DEBUG)
{
source("MSdiffexp_definitions.R")
}
perform_analysis<-function(){
levellog("",change=1)
setwd(working_directory)
rep_structure<-read.table(experimental_structure_file,col.names=c('raw_file','biorep','techrep','fraction'), sep="\t")
rep_structure<-rep_structure[order(rep_structure[,2],rep_structure[,3],rep_structure[,4]),]
LFQ_conds<-c()
if(LabelFree)
{
#if labelfree load the lfq conditions structure
LFQ_conds<-read.table(LFQ_conditions_file, col.names=c('raw_file', 'condition'), stringsAsFactors = F)
}
if (AllowLabelRename == T)
{
Rename_Array <<- read.table(Rename_Array_file, col.names=c('old_label', 'new_label'), stringsAsFactors = F)
}
if (AllowLS == T)
{
Ls_array <<- read.table(LS_Array_file, col.names=c('selected_raw_file', 'first_label', 'second_label'), stringsAsFactors = F)
}
if (RMisused == T)
{
RMrawfilesdata <<- read.table(RMrawfilesdata_file, col.names=c('id', 'name', 'brep', 'trep', 'frac', 'cond', 'used', 'selected'), stringsAsFactors = F)
}
if (RMisused == T)
{
RMtagsdata <<- read.table(RMtagsdata_file, col.names=c('id', 'name', 'brep', 'trep', 'frac', 'cond', 'used', 'selected'), stringsAsFactors = F)
}
#Because a condition can not be named "N" in ProteoSign, rename it to condN
mi <- which(LFQ_conds$condition == "N")
if(length(mi)>0)
{
levels(LFQ_conds$condition) <- c(levels(LFQ_conds$condition), "condN")
LFQ_conds$condition[which(LFQ_conds$condition == "N")] <- "condN"
LFQ_conds$condition <- factor(LFQ_conds$condition)
}
#take care of the same problem in conditions.labels as well
#a condition can not be named "N" so just for this case rename it to condN
for(i in 1:length(conditions.labels)){
if(conditions.labels[i] == "N")
{
conditions.labels[i] <- "condN"
conditions.labels <<- conditions.labels
}
}
if(filterL_lbl == "N")
{
filterL_lbl <<- "condN"
}
#we will keep a copy of the original rep_structure to display in the graphs
original_rep_structure <- rep_structure
#we are not sure if the biorep and techrep numbers the user typed are sequential, the following code converts them to sequential numbers
unique_reps <- unique(rep_structure$biorep)
counter <- 1
for(rep_i in unique_reps){
mi <- which(rep_structure$biorep == rep_i)
rep_structure$biorep[mi] <- counter
counter <- counter + 1
unique_techreps <- unique(rep_structure$techrep[mi])
counter2 <- 1
for(techrep_i in unique_techreps){
mi2 <- which(rep_structure$biorep == counter - 1 & rep_structure$techrep == techrep_i)
rep_structure$techrep[mi2] <- counter2
counter2 <- counter2 + 1
}
}
original_rep_structure$rep_desc<-paste(paste(paste('b',original_rep_structure$biorep,sep=''),'t',original_rep_structure$techrep,sep=''))
if (!RMisused)
{
if(length(unique(rep_structure$biorep)) == 1){
levellog("Error User: Cannot accept dataset with just one biological replicate. Aborting ...")
return(F)
# single_brep_file <<- T
# nRequiredLeastBioreps <<- 1
# } else {
# single_brep_file <<- F
}
}
if(length(unique(rep_structure$techrep)) > 1){
if(length(unique(rep_structure$fraction)) > 1){
# we have techreps and fractions
rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
original_rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
}else{
#we have bioreps and techreps
rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
original_rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
}
}else{
if(length(unique(rep_structure$fraction)) > 1){
# we have fractions but not techreps
rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
original_rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
}else{
# we just have bioreps
rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
original_rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
# it should be like below, but for backward compatibility with other parts of the code, we keep the convention that in the rep. description, we will always have the terms 'b' (i.e. bio-rep) and 't', even if we don't have tech-reps ...
# rep_structure$rep_desc<-paste('b',rep_structure$biorep,sep='')
}
}
.GlobalEnv[["rep_structure"]]<-rep_structure
.GlobalEnv[["LFQ_conds"]]<-LFQ_conds
.GlobalEnv[["original_rep_structure"]]<-original_rep_structure
.GlobalEnv[["n_bioreps"]]<-max(rep_structure$biorep)
.GlobalEnv[["n_techreps"]]<-min(ddply(rep_structure[,c("biorep","techrep")],c("biorep"),function(x){return(max(x$techrep))})$V1)
if(ProteinQuantitation){
quantitated_items_lbl<<-"Protein"
}else{
quantitated_items_lbl<<-"Peptide"
}
if(file.exists(limma_output)){
unlink(limma_output, recursive=T, force=T)
}
dir.create(limma_output)
if(grepl("\"",readLines(evidence_fname, n=1))){
levellog("Removing double quotes from input data file #1 ...")
tmpdata<-gsub("\"", "", readLines(evidence_fname))
evidence_fname_cleaned<-file(evidence_fname, open="w")
writeLines(tmpdata, con=evidence_fname_cleaned)
close(evidence_fname_cleaned)
}
levellog("Reading input data ...")
if(PDdata){
protein_groups<<-read.pgroups_v3(pgroups_fname,evidence_fname,time.point,keepEvidenceIDs=T)
}else{
if(grepl("\"",readLines(pgroups_fname, n=1))){
levellog("Removing double quotes from input data file #2 ...")
tmpdata<-gsub("\"", "", readLines(pgroups_fname))
pgroups_fname_cleaned<-file(pgroups_fname, open="w")
writeLines(tmpdata, con=pgroups_fname_cleaned)
close(pgroups_fname_cleaned)
}
protein_groups<<-read.pgroups_v3(pgroups_fname,evidence_fname,time.point,keepEvidenceIDs=T)
}
#Restore the original rep descriptions to add to the graph
if (!RMisused)
{
newcolumns <- names(protein_groups)
oldcolumns = newcolumns
for(my_column in newcolumns){
for(my_repdesc in .GlobalEnv[["rep_structure"]]$rep_desc){
if (grepl(my_repdesc, my_column)){
temp_name <- .GlobalEnv[["original_rep_structure"]]$rep_desc[match(my_repdesc, .GlobalEnv[["rep_structure"]]$rep_desc)]
newcolumns[match(my_column, newcolumns)] <- sub(my_repdesc, temp_name, my_column)
}
}
}
colnames(protein_groups) <- newcolumns
}
setwd(limma_output)
temp_pgroups <- protein_groups
write.table(temp_pgroups[, -which(names(temp_pgroups) %in% c("N.x","N.y"))],file=paste(outputFigsPrefix,"_proteinGroupsDF.txt",sep=""),row.names=F,sep="\t")
setwd("..")
if (!RMisused)
{
colnames(protein_groups) <- oldcolumns
}
#Create the expdesign table:
expdesign<-c()
#Rename conditions labels from condN back to N
for(i in 1:length(conditions.labels)){
if(conditions.labels[i] == "condN")
{
conditions.labels[i] <- "N"
conditions.labels <<- conditions.labels
colnames(protein_groups) <- sub("condN", "N", colnames(protein_groups))
}
}
if(filterL_lbl == "condN")
{
filterL_lbl <<- "N"
}
#Rename condN back to N in lfq_conds and protein_groups
mi <- which(LFQ_conds$condition == "condN")
if(length(mi)>0)
{
levels(LFQ_conds$condition) <- c(levels(LFQ_conds$condition), "N")
LFQ_conds$condition[which(LFQ_conds$condition == "condN")] <- "N"
LFQ_conds$condition <- factor(LFQ_conds$condition)
LFQ_conds <<- LFQ_conds
colnames(protein_groups) <- sub("condN", "N", colnames(protein_groups))
}
for(cond_i in conditions.labels){
expdesign<-rbind(expdesign,cbind(paste(sub("Intensity\\.","",sort(colnames(protein_groups)[grep(paste("Intensity.",cond_i,".b",sep=""),colnames(protein_groups))]))),cond_i))
}
colnames(expdesign)<-c("Sample","Category")
if(!RMisused){
#the following lines also deal with restoring the original breps and treps numbers
#temp vector has only the information of the replication (e.g. b1t1 or b1t1f1 if we have fractionation)
temp_vector <- sub("(.*)\\.","", expdesign[,1])
temp_vector <- original_rep_structure$rep_desc[match(temp_vector, sub("f.*", "", rep_structure$rep_desc))]
#Make sure that expdesign (column Sample) contains data in te right format by merging expdesign and tmp_vector:
tmp_counter <- 0
for (expdesign_i in expdesign[,1]){
expdesign[tmp_counter + 1,1] <- sub("(.*)\\..*",paste0("\\1.", temp_vector[tmp_counter + 1]), expdesign_i)
tmp_counter <- tmp_counter + 1
}
}
#Remove the fractionation information: (if any)
expdesign[,1] <- sub("(.*\\..*)f.*", "\\1", expdesign[,1], perl = TRUE)
write.table(expdesign,file="curr_exp_design.txt",row.names=F,quote=F,sep = "\t")
exp_design_fname<<-"curr_exp_design.txt"
levellog("Performing the analysis ...")
norm.median.intensities <- do_limma_analysis(prepare_working_pgroups(protein_groups),time.point,exp_design_fname,exportFormat="pdf",outputFigsPrefix=outputFigsPrefix)
levellog("Generating analysis plots ...")
results<-do_results_plots(norm.median.intensities, time.point, exportFormat="pdf", outputFigsPrefix=outputFigsPrefix)
setwd("..")
levellog("",change=-1)
levellog("Data analysis finished.")
levellog("",change=-1)
return(T)
}
#================ PRODUCTION ===============
setwd("E:/xampp/htdocs/ProteoSign_v2/uploads/1617191158749/msdiffexp_wd")
levellog("",change=1)
setwd(working_directory)
rep_structure<-read.table(experimental_structure_file,col.names=c('raw_file','biorep','techrep','fraction'), sep="\t")
rep_structure<-rep_structure[order(rep_structure[,2],rep_structure[,3],rep_structure[,4]),]
LFQ_conds<-c()
if(LabelFree)
{
#if labelfree load the lfq conditions structure
LFQ_conds<-read.table(LFQ_conditions_file, col.names=c('raw_file', 'condition'), stringsAsFactors = F)
}
if (AllowLabelRename == T)
{
Rename_Array <<- read.table(Rename_Array_file, col.names=c('old_label', 'new_label'), stringsAsFactors = F)
}
if (AllowLS == T)
{
Ls_array <<- read.table(LS_Array_file, col.names=c('selected_raw_file', 'first_label', 'second_label'), stringsAsFactors = F)
}
if (RMisused == T)
{
RMrawfilesdata <<- read.table(RMrawfilesdata_file, col.names=c('id', 'name', 'brep', 'trep', 'frac', 'cond', 'used', 'selected'), stringsAsFactors = F)
}
if (RMisused == T)
{
RMtagsdata <<- read.table(RMtagsdata_file, col.names=c('id', 'name', 'brep', 'trep', 'frac', 'cond', 'used', 'selected'), stringsAsFactors = F)
}
#Because a condition can not be named "N" in ProteoSign, rename it to condN
mi <- which(LFQ_conds$condition == "N")
if(length(mi)>0)
{
levels(LFQ_conds$condition) <- c(levels(LFQ_conds$condition), "condN")
LFQ_conds$condition[which(LFQ_conds$condition == "N")] <- "condN"
LFQ_conds$condition <- factor(LFQ_conds$condition)
}
#take care of the same problem in conditions.labels as well
#a condition can not be named "N" so just for this case rename it to condN
for(i in 1:length(conditions.labels)){
if(conditions.labels[i] == "N")
{
conditions.labels[i] <- "condN"
conditions.labels <<- conditions.labels
}
}
if(filterL_lbl == "N")
{
filterL_lbl <<- "condN"
}
#we will keep a copy of the original rep_structure to display in the graphs
original_rep_structure <- rep_structure
#we are not sure if the biorep and techrep numbers the user typed are sequential, the following code converts them to sequential numbers
unique_reps <- unique(rep_structure$biorep)
counter <- 1
for(rep_i in unique_reps){
mi <- which(rep_structure$biorep == rep_i)
rep_structure$biorep[mi] <- counter
counter <- counter + 1
unique_techreps <- unique(rep_structure$techrep[mi])
counter2 <- 1
for(techrep_i in unique_techreps){
mi2 <- which(rep_structure$biorep == counter - 1 & rep_structure$techrep == techrep_i)
rep_structure$techrep[mi2] <- counter2
counter2 <- counter2 + 1
}
}
original_rep_structure$rep_desc<-paste(paste(paste('b',original_rep_structure$biorep,sep=''),'t',original_rep_structure$techrep,sep=''))
if (!RMisused)
{
if(length(unique(rep_structure$biorep)) == 1){
levellog("Error User: Cannot accept dataset with just one biological replicate. Aborting ...")
return(F)
# single_brep_file <<- T
# nRequiredLeastBioreps <<- 1
# } else {
# single_brep_file <<- F
}
}
if(length(unique(rep_structure$techrep)) > 1){
if(length(unique(rep_structure$fraction)) > 1){
# we have techreps and fractions
rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
original_rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
}else{
#we have bioreps and techreps
rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
original_rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
}
}else{
if(length(unique(rep_structure$fraction)) > 1){
# we have fractions but not techreps
rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
original_rep_structure$rep_desc<-paste(paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep=''),'f',rep_structure$fraction,sep='')
}else{
# we just have bioreps
rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
original_rep_structure$rep_desc<-paste(paste('b',rep_structure$biorep,sep=''),'t',rep_structure$techrep,sep='')
# it should be like below, but for backward compatibility with other parts of the code, we keep the convention that in the rep. description, we will always have the terms 'b' (i.e. bio-rep) and 't', even if we don't have tech-reps ...
# rep_structure$rep_desc<-paste('b',rep_structure$biorep,sep='')
}
}
.GlobalEnv[["rep_structure"]]<-rep_structure
.GlobalEnv[["LFQ_conds"]]<-LFQ_conds
.GlobalEnv[["original_rep_structure"]]<-original_rep_structure
.GlobalEnv[["n_bioreps"]]<-max(rep_structure$biorep)
.GlobalEnv[["n_techreps"]]<-min(ddply(rep_structure[,c("biorep","techrep")],c("biorep"),function(x){return(max(x$techrep))})$V1)
if(ProteinQuantitation){
quantitated_items_lbl<<-"Protein"
}else{
quantitated_items_lbl<<-"Peptide"
}
if(file.exists(limma_output)){
unlink(limma_output, recursive=T, force=T)
}
dir.create(limma_output)
if(grepl("\"",readLines(evidence_fname, n=1))){
levellog("Removing double quotes from input data file #1 ...")
tmpdata<-gsub("\"", "", readLines(evidence_fname))
evidence_fname_cleaned<-file(evidence_fname, open="w")
writeLines(tmpdata, con=evidence_fname_cleaned)
close(evidence_fname_cleaned)
}
levellog("Reading input data ...")
if(PDdata){
protein_groups<<-read.pgroups_v3(pgroups_fname,evidence_fname,time.point,keepEvidenceIDs=T)
}else{
if(grepl("\"",readLines(pgroups_fname, n=1))){
levellog("Removing double quotes from input data file #2 ...")
tmpdata<-gsub("\"", "", readLines(pgroups_fname))
pgroups_fname_cleaned<-file(pgroups_fname, open="w")
writeLines(tmpdata, con=pgroups_fname_cleaned)
close(pgroups_fname_cleaned)
}
protein_groups<<-read.pgroups_v3(pgroups_fname,evidence_fname,time.point,keepEvidenceIDs=T)
}
#Restore the original rep descriptions to add to the graph
if (!RMisused)
{
newcolumns <- names(protein_groups)
oldcolumns = newcolumns
for(my_column in newcolumns){
for(my_repdesc in .GlobalEnv[["rep_structure"]]$rep_desc){
if (grepl(my_repdesc, my_column)){
temp_name <- .GlobalEnv[["original_rep_structure"]]$rep_desc[match(my_repdesc, .GlobalEnv[["rep_structure"]]$rep_desc)]
newcolumns[match(my_column, newcolumns)] <- sub(my_repdesc, temp_name, my_column)
}
}
}
colnames(protein_groups) <- newcolumns
}
setwd(limma_output)
temp_pgroups <- protein_groups
write.table(temp_pgroups[, -which(names(temp_pgroups) %in% c("N.x","N.y"))],file=paste(outputFigsPrefix,"_proteinGroupsDF.txt",sep=""),row.names=F,sep="\t")
setwd("..")
if (!RMisused)
{
colnames(protein_groups) <- oldcolumns
}
#Create the expdesign table:
expdesign<-c()
#Rename conditions labels from condN back to N
for(i in 1:length(conditions.labels)){
if(conditions.labels[i] == "condN")
{
conditions.labels[i] <- "N"
conditions.labels <<- conditions.labels
colnames(protein_groups) <- sub("condN", "N", colnames(protein_groups))
}
}
if(filterL_lbl == "condN")
{
filterL_lbl <<- "N"
}
#Rename condN back to N in lfq_conds and protein_groups
mi <- which(LFQ_conds$condition == "condN")
if(length(mi)>0)
{
levels(LFQ_conds$condition) <- c(levels(LFQ_conds$condition), "N")
LFQ_conds$condition[which(LFQ_conds$condition == "condN")] <- "N"
LFQ_conds$condition <- factor(LFQ_conds$condition)
LFQ_conds <<- LFQ_conds
colnames(protein_groups) <- sub("condN", "N", colnames(protein_groups))
}
for(cond_i in conditions.labels){
expdesign<-rbind(expdesign,cbind(paste(sub("Intensity\\.","",sort(colnames(protein_groups)[grep(paste("Intensity.",cond_i,".b",sep=""),colnames(protein_groups))]))),cond_i))
}
colnames(expdesign)<-c("Sample","Category")
if(!RMisused){
#the following lines also deal with restoring the original breps and treps numbers
#temp vector has only the information of the replication (e.g. b1t1 or b1t1f1 if we have fractionation)
temp_vector <- sub("(.*)\\.","", expdesign[,1])
temp_vector <- original_rep_structure$rep_desc[match(temp_vector, sub("f.*", "", rep_structure$rep_desc))]
#Make sure that expdesign (column Sample) contains data in te right format by merging expdesign and tmp_vector:
tmp_counter <- 0
for (expdesign_i in expdesign[,1]){
expdesign[tmp_counter + 1,1] <- sub("(.*)\\..*",paste0("\\1.", temp_vector[tmp_counter + 1]), expdesign_i)
tmp_counter <- tmp_counter + 1
}
}
#Remove the fractionation information: (if any)
expdesign[,1] <- sub("(.*\\..*)f.*", "\\1", expdesign[,1], perl = TRUE)
write.table(expdesign,file="curr_exp_design.txt",row.names=F,quote=F,sep = "\t")
exp_design_fname<<-"curr_exp_design.txt"
levellog("Performing the analysis ...")
norm.median.intensities <- do_limma_analysis(prepare_working_pgroups(protein_groups),time.point,exp_design_fname,exportFormat="pdf",outputFigsPrefix=outputFigsPrefix)
levellog("Generating analysis plots ...")
results<-do_results_plots(norm.median.intensities, time.point, exportFormat="pdf", outputFigsPrefix=outputFigsPrefix)
q
